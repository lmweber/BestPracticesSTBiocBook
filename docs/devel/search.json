[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "BestPracticesSTBiocBook",
    "section": "",
    "text": "Package: BestPracticesSTBiocBookAuthors: First Last [aut, cre]Compiled: 2024-09-26Package version: 0.98.0R version: R version 4.4.1 (2024-06-14)BioC version: 3.20License: MIT + file LICENSE\nWelcome\nThis is the website for the online book ‚ÄòBest Practices for Spatial Transcriptomics Analysis with Bioconductor‚Äô.\nThis book provides discussion and interactive examples on best practices for computational analysis workflows for spatial transcriptomics data, using the Bioconductor framework within R. The chapters contain details on individual analysis steps as well as complete example workflows, with interactive example datasets and R code.\nThe book is organized into several parts, including introductory materials, analysis steps, and example workflows.\nAdditional details on analysis workflows for non-spatial single-cell data as well as further introductory materials on R and Bioconductor can be found in the related book Orchestrating Single-Cell Analysis with Bioconductor (OSCA).\nDocker image\nA Docker image built from this repository is available here:\nüëâ ghcr.io/lmweber/bestpracticesstbiocbook üê≥\n\n\n\n\n\n\nGet started now üéâ\n\n\n\nYou can get access to all the packages used in this book in &lt; 1 minute, using this command in a terminal:\n\n\n\nbash\n\ndocker run -it ghcr.io/lmweber/bestpracticesstbiocbook:devel R\n\n\n\n\nRStudio Server\nAn RStudio Server instance can be initiated from the Docker image as follows:\n\n\n\nbash\n\ndocker run \\\n    --volume &lt;local_folder&gt;:&lt;destination_folder&gt; \\\n    -e PASSWORD=OHCA \\\n    -p 8787:8787 \\\n    ghcr.io/lmweber/bestpracticesstbiocbook:devel\n\n\nThe initiated RStudio Server instance will be available at https://localhost:8787.\n\nSession info\n\n\n\n\n\n\nClick to expand üëá\n\n\n\n\n\n\nsessioninfo::session_info(\n    installed.packages()[,\"Package\"], \n    include_base = TRUE\n)\n##  ‚îÄ Session info ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n##   setting  value\n##   version  R version 4.4.1 (2024-06-14)\n##   os       Ubuntu 22.04.4 LTS\n##   system   x86_64, linux-gnu\n##   ui       X11\n##   language (EN)\n##   collate  C\n##   ctype    en_US.UTF-8\n##   tz       Etc/UTC\n##   date     2024-09-26\n##   pandoc   3.3 @ /usr/bin/ (via rmarkdown)\n##  \n##  ‚îÄ Packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n##   package                 * version   date (UTC) lib source\n##   abind                     1.4-8     2024-09-12 [2] RSPM (R 4.4.0)\n##   AnnotationDbi             1.67.0    2024-05-01 [2] Bioconductor 3.20 (R 4.4.0)\n##   AnnotationHub             3.13.3    2024-08-19 [2] Bioconductor 3.20 (R 4.4.1)\n##   askpass                   1.2.0     2023-09-03 [2] RSPM (R 4.4.0)\n##   assorthead                0.99.8    2024-09-17 [2] Bioconductor 3.20 (R 4.4.1)\n##   base                    * 4.4.1     2024-08-09 [3] local\n##   base64enc                 0.1-3     2015-07-28 [2] RSPM (R 4.4.0)\n##   beachmat                  2.21.6    2024-09-05 [2] Bioconductor 3.20 (R 4.4.1)\n##   beeswarm                  0.4.0     2021-06-01 [2] RSPM (R 4.4.0)\n##   BestPracticesSTBiocBook   0.98.0    2024-09-26 [1] local\n##   BH                        1.84.0-0  2024-01-10 [2] RSPM (R 4.4.0)\n##   Biobase                   2.65.1    2024-08-28 [2] Bioconductor 3.20 (R 4.4.1)\n##   BiocFileCache             2.13.0    2024-05-01 [2] Bioconductor 3.20 (R 4.4.0)\n##   BiocGenerics              0.51.1    2024-09-03 [2] Bioconductor 3.20 (R 4.4.1)\n##   BiocManager               1.30.25   2024-08-28 [2] CRAN (R 4.4.1)\n##   BiocNeighbors             1.99.1    2024-09-22 [2] Bioconductor 3.20 (R 4.4.1)\n##   BiocParallel              1.39.0    2024-05-01 [2] Bioconductor 3.20 (R 4.4.0)\n##   BiocSingular              1.21.4    2024-09-22 [2] Bioconductor 3.20 (R 4.4.1)\n##   BiocStyle                 2.33.1    2024-06-12 [2] Bioconductor 3.20 (R 4.4.0)\n##   BiocVersion               3.20.0    2024-05-01 [2] Bioconductor 3.20 (R 4.4.1)\n##   Biostrings                2.73.1    2024-06-02 [2] Bioconductor 3.20 (R 4.4.0)\n##   bit                       4.5.0     2024-09-20 [2] RSPM (R 4.4.0)\n##   bit64                     4.5.2     2024-09-22 [2] RSPM (R 4.4.0)\n##   blob                      1.2.4     2023-03-17 [2] RSPM (R 4.4.0)\n##   bluster                   1.15.1    2024-09-06 [2] Bioconductor 3.20 (R 4.4.1)\n##   bookdown                  0.40      2024-07-02 [2] RSPM (R 4.4.0)\n##   boot                      1.3-31    2024-08-28 [2] RSPM (R 4.4.0)\n##   brew                      1.0-10    2023-12-16 [2] RSPM (R 4.4.0)\n##   brio                      1.1.5     2024-04-24 [2] RSPM (R 4.4.0)\n##   BRISC                     1.0.5     2022-04-29 [2] RSPM (R 4.4.0)\n##   bslib                     0.8.0     2024-07-29 [2] RSPM (R 4.4.0)\n##   cachem                    1.1.0     2024-05-16 [2] RSPM (R 4.4.0)\n##   Cairo                     1.6-2     2023-11-28 [2] RSPM (R 4.4.0)\n##   callr                     3.7.6     2024-03-25 [2] RSPM (R 4.4.0)\n##   class                     7.3-22    2023-05-03 [3] CRAN (R 4.4.1)\n##   cli                       3.6.3     2024-06-21 [2] RSPM (R 4.4.0)\n##   clipr                     0.8.0     2022-02-22 [2] RSPM (R 4.4.0)\n##   cluster                   2.1.6     2023-12-01 [3] CRAN (R 4.4.1)\n##   codetools                 0.2-20    2024-03-31 [3] CRAN (R 4.4.1)\n##   colorspace                2.1-1     2024-07-26 [2] RSPM (R 4.4.0)\n##   commonmark                1.9.1     2024-01-30 [2] RSPM (R 4.4.0)\n##   compiler                  4.4.1     2024-08-09 [3] local\n##   cpp11                     0.5.0     2024-08-27 [2] RSPM (R 4.4.0)\n##   crayon                    1.5.3     2024-06-20 [2] RSPM (R 4.4.0)\n##   credentials               2.0.1     2023-09-06 [2] RSPM (R 4.4.0)\n##   curl                      5.2.3     2024-09-20 [2] RSPM (R 4.4.0)\n##   datasets                * 4.4.1     2024-08-09 [3] local\n##   DBI                       1.2.3     2024-06-02 [2] RSPM (R 4.4.0)\n##   dbplyr                    2.5.0     2024-03-19 [2] RSPM (R 4.4.0)\n##   DelayedArray              0.31.11   2024-08-04 [2] Bioconductor 3.20 (R 4.4.1)\n##   desc                      1.4.3     2023-12-10 [2] RSPM (R 4.4.0)\n##   devtools                  2.4.5     2022-10-11 [2] RSPM (R 4.4.0)\n##   diffobj                   0.3.5     2021-10-05 [2] RSPM (R 4.4.0)\n##   digest                    0.6.37    2024-08-19 [2] RSPM (R 4.4.0)\n##   docopt                    0.7.1     2020-06-24 [2] RSPM (R 4.4.1)\n##   downlit                   0.4.4     2024-06-10 [2] RSPM (R 4.4.0)\n##   dplyr                     1.1.4     2023-11-17 [2] RSPM (R 4.4.0)\n##   dqrng                     0.4.1     2024-05-28 [2] RSPM (R 4.4.0)\n##   edgeR                     4.3.16    2024-09-22 [2] Bioconductor 3.20 (R 4.4.1)\n##   ellipsis                  0.3.2     2021-04-29 [2] RSPM (R 4.4.0)\n##   evaluate                  1.0.0     2024-09-17 [2] RSPM (R 4.4.0)\n##   ExperimentHub             2.13.1    2024-07-31 [2] Bioconductor 3.20 (R 4.4.1)\n##   fansi                     1.0.6     2023-12-08 [2] RSPM (R 4.4.0)\n##   farver                    2.1.2     2024-05-13 [2] RSPM (R 4.4.0)\n##   fastmap                   1.2.0     2024-05-15 [2] RSPM (R 4.4.0)\n##   filelock                  1.0.3     2023-12-11 [2] RSPM (R 4.4.0)\n##   FNN                       1.1.4.1   2024-09-22 [2] RSPM (R 4.4.0)\n##   fontawesome               0.5.2     2023-08-19 [2] RSPM (R 4.4.0)\n##   foreign                   0.8-87    2024-06-26 [2] RSPM (R 4.4.0)\n##   formatR                   1.14      2023-01-17 [2] RSPM (R 4.4.0)\n##   fs                        1.6.4     2024-04-25 [2] RSPM (R 4.4.0)\n##   futile.logger             1.4.3     2016-07-10 [2] RSPM (R 4.4.0)\n##   futile.options            1.0.1     2018-04-20 [2] RSPM (R 4.4.0)\n##   generics                  0.1.3     2022-07-05 [2] RSPM (R 4.4.0)\n##   GenomeInfoDb              1.41.1    2024-05-24 [2] Bioconductor 3.20 (R 4.4.0)\n##   GenomeInfoDbData          1.2.12    2024-06-24 [2] Bioconductor\n##   GenomicRanges             1.57.1    2024-06-12 [2] Bioconductor 3.20 (R 4.4.0)\n##   gert                      2.1.1     2024-08-16 [2] RSPM (R 4.4.0)\n##   ggbeeswarm                0.7.2     2023-04-29 [2] RSPM (R 4.4.0)\n##   ggplot2                   3.5.1     2024-04-23 [2] RSPM (R 4.4.0)\n##   ggrastr                   1.0.2     2023-06-01 [2] RSPM (R 4.4.0)\n##   ggrepel                   0.9.6     2024-09-07 [2] RSPM (R 4.4.0)\n##   ggside                    0.3.1     2024-03-01 [2] RSPM (R 4.4.0)\n##   ggspavis                  1.11.0    2024-05-17 [2] Bioconductor 3.20 (R 4.4.0)\n##   gh                        1.4.1     2024-03-28 [2] RSPM (R 4.4.0)\n##   gitcreds                  0.1.2     2022-09-08 [2] RSPM (R 4.4.0)\n##   glue                      1.7.0     2024-01-09 [2] RSPM (R 4.4.0)\n##   graphics                * 4.4.1     2024-08-09 [3] local\n##   grDevices               * 4.4.1     2024-08-09 [3] local\n##   grid                      4.4.1     2024-08-09 [3] local\n##   gridExtra                 2.3       2017-09-09 [2] RSPM (R 4.4.0)\n##   gtable                    0.3.5     2024-04-22 [2] RSPM (R 4.4.0)\n##   highr                     0.11      2024-05-26 [2] RSPM (R 4.4.0)\n##   htmltools                 0.5.8.1   2024-04-04 [2] RSPM (R 4.4.0)\n##   htmlwidgets               1.6.4     2023-12-06 [2] RSPM (R 4.4.0)\n##   httpuv                    1.6.15    2024-03-26 [2] RSPM (R 4.4.0)\n##   httr                      1.4.7     2023-08-15 [2] RSPM (R 4.4.0)\n##   httr2                     1.0.3     2024-08-22 [2] RSPM (R 4.4.0)\n##   igraph                    2.0.3     2024-03-13 [2] RSPM (R 4.4.0)\n##   ini                       0.3.1     2018-05-20 [2] RSPM (R 4.4.0)\n##   IRanges                   2.39.2    2024-07-17 [2] Bioconductor 3.20 (R 4.4.1)\n##   irlba                     2.3.5.1   2022-10-03 [2] RSPM (R 4.4.0)\n##   isoband                   0.2.7     2022-12-20 [2] RSPM (R 4.4.0)\n##   jquerylib                 0.1.4     2021-04-26 [2] RSPM (R 4.4.0)\n##   jsonlite                  1.8.9     2024-09-20 [2] RSPM (R 4.4.0)\n##   KEGGREST                  1.45.1    2024-06-17 [2] Bioconductor 3.20 (R 4.4.0)\n##   KernSmooth                2.23-24   2024-05-17 [3] CRAN (R 4.4.1)\n##   knitr                     1.48      2024-07-07 [2] RSPM (R 4.4.0)\n##   labeling                  0.4.3     2023-08-29 [2] RSPM (R 4.4.0)\n##   lambda.r                  1.2.4     2019-09-18 [2] RSPM (R 4.4.0)\n##   later                     1.3.2     2023-12-06 [2] RSPM (R 4.4.0)\n##   lattice                   0.22-6    2024-03-20 [3] CRAN (R 4.4.1)\n##   lifecycle                 1.0.4     2023-11-07 [2] RSPM (R 4.4.0)\n##   limma                     3.61.10   2024-09-22 [2] Bioconductor 3.20 (R 4.4.1)\n##   littler                   0.3.20    2024-03-23 [2] RSPM (R 4.4.1)\n##   locfit                    1.5-9.10  2024-06-24 [2] RSPM (R 4.4.0)\n##   magick                    2.8.5     2024-09-20 [2] RSPM (R 4.4.0)\n##   magrittr                  2.0.3     2022-03-30 [2] RSPM (R 4.4.0)\n##   MASS                      7.3-61    2024-06-13 [2] RSPM (R 4.4.0)\n##   Matrix                    1.7-0     2024-04-26 [3] CRAN (R 4.4.1)\n##   MatrixGenerics            1.17.0    2024-05-01 [2] Bioconductor 3.20 (R 4.4.0)\n##   matrixStats               1.4.1     2024-09-08 [2] RSPM (R 4.4.0)\n##   memoise                   2.0.1     2021-11-26 [2] RSPM (R 4.4.0)\n##   metapod                   1.13.0    2024-05-01 [2] Bioconductor 3.20 (R 4.4.0)\n##   methods                 * 4.4.1     2024-08-09 [3] local\n##   mgcv                      1.9-1     2023-12-21 [3] CRAN (R 4.4.1)\n##   mime                      0.12      2021-09-28 [2] RSPM (R 4.4.0)\n##   miniUI                    0.1.1.1   2018-05-18 [2] RSPM (R 4.4.0)\n##   munsell                   0.5.1     2024-04-01 [2] RSPM (R 4.4.0)\n##   nlme                      3.1-166   2024-08-14 [2] RSPM (R 4.4.0)\n##   nnet                      7.3-19    2023-05-03 [3] CRAN (R 4.4.1)\n##   nnSVG                     1.9.0     2024-05-17 [2] Bioconductor 3.20 (R 4.4.0)\n##   openssl                   2.2.2     2024-09-20 [2] RSPM (R 4.4.0)\n##   parallel                  4.4.1     2024-08-09 [3] local\n##   pbapply                   1.7-2     2023-06-27 [2] RSPM (R 4.4.0)\n##   pheatmap                  1.0.12    2019-01-04 [2] RSPM (R 4.4.0)\n##   pillar                    1.9.0     2023-03-22 [2] RSPM (R 4.4.0)\n##   pkgbuild                  1.4.4     2024-03-17 [2] RSPM (R 4.4.0)\n##   pkgconfig                 2.0.3     2019-09-22 [2] RSPM (R 4.4.0)\n##   pkgdown                   2.1.0     2024-07-06 [2] RSPM (R 4.4.0)\n##   pkgload                   1.4.0     2024-06-28 [2] RSPM (R 4.4.0)\n##   plogr                     0.2.0     2018-03-25 [2] RSPM (R 4.4.0)\n##   png                       0.1-8     2022-11-29 [2] RSPM (R 4.4.0)\n##   praise                    1.0.0     2015-08-11 [2] RSPM (R 4.4.0)\n##   preprocessCore            1.67.0    2024-05-01 [2] Bioconductor 3.20 (R 4.4.1)\n##   prettyunits               1.2.0     2023-09-24 [2] RSPM (R 4.4.0)\n##   processx                  3.8.4     2024-03-16 [2] RSPM (R 4.4.0)\n##   profvis                   0.3.8     2023-05-02 [2] RSPM (R 4.4.0)\n##   promises                  1.3.0     2024-04-05 [2] RSPM (R 4.4.0)\n##   ps                        1.8.0     2024-09-12 [2] RSPM (R 4.4.0)\n##   purrr                     1.0.2     2023-08-10 [2] RSPM (R 4.4.0)\n##   R6                        2.5.1     2021-08-19 [2] RSPM (R 4.4.0)\n##   ragg                      1.3.3     2024-09-11 [2] RSPM (R 4.4.0)\n##   RANN                      2.6.2     2024-08-25 [2] RSPM (R 4.4.0)\n##   rappdirs                  0.3.3     2021-01-31 [2] RSPM (R 4.4.0)\n##   rcmdcheck                 1.4.0     2021-09-27 [2] RSPM (R 4.4.0)\n##   RColorBrewer              1.1-3     2022-04-03 [2] RSPM (R 4.4.0)\n##   Rcpp                      1.0.13    2024-07-17 [2] RSPM (R 4.4.0)\n##   RcppAnnoy                 0.0.22    2024-01-23 [2] RSPM (R 4.4.0)\n##   RcppArmadillo             14.0.2-1  2024-09-12 [2] RSPM (R 4.4.0)\n##   RcppEigen                 0.3.4.0.2 2024-08-24 [2] RSPM (R 4.4.0)\n##   RcppML                    0.3.7     2021-09-21 [2] RSPM (R 4.4.0)\n##   RcppProgress              0.4.2     2020-02-06 [2] RSPM (R 4.4.0)\n##   rdist                     0.0.5     2020-05-04 [2] RSPM (R 4.4.0)\n##   rematch2                  2.1.2     2020-05-01 [2] RSPM (R 4.4.0)\n##   remotes                   2.5.0     2024-03-17 [2] RSPM (R 4.4.0)\n##   rjson                     0.2.23    2024-09-16 [2] RSPM (R 4.4.0)\n##   rlang                     1.1.4     2024-06-04 [2] RSPM (R 4.4.0)\n##   rmarkdown                 2.28      2024-08-17 [2] RSPM (R 4.4.0)\n##   roxygen2                  7.3.2     2024-06-28 [2] RSPM (R 4.4.0)\n##   rpart                     4.1.23    2023-12-05 [3] CRAN (R 4.4.1)\n##   rprojroot                 2.0.4     2023-11-05 [2] RSPM (R 4.4.0)\n##   RSpectra                  0.16-2    2024-07-18 [2] RSPM (R 4.4.0)\n##   RSQLite                   2.3.7     2024-05-27 [2] RSPM (R 4.4.0)\n##   rstudioapi                0.16.0    2024-03-24 [2] RSPM (R 4.4.0)\n##   rsvd                      1.0.5     2021-04-16 [2] RSPM (R 4.4.0)\n##   Rtsne                     0.17      2023-12-07 [2] RSPM (R 4.4.0)\n##   rversions                 2.1.2     2022-08-31 [2] RSPM (R 4.4.0)\n##   S4Arrays                  1.5.8     2024-09-22 [2] Bioconductor 3.20 (R 4.4.1)\n##   S4Vectors                 0.43.2    2024-07-17 [2] Bioconductor 3.20 (R 4.4.1)\n##   sass                      0.4.9     2024-03-15 [2] RSPM (R 4.4.0)\n##   ScaledMatrix              1.13.0    2024-05-01 [2] Bioconductor 3.20 (R 4.4.0)\n##   scales                    1.3.0     2023-11-28 [2] RSPM (R 4.4.0)\n##   scater                    1.33.4    2024-07-21 [2] Bioconductor 3.20 (R 4.4.1)\n##   scran                     1.33.2    2024-09-06 [2] Bioconductor 3.20 (R 4.4.1)\n##   scuttle                   1.15.4    2024-08-14 [2] Bioconductor 3.20 (R 4.4.1)\n##   sessioninfo               1.2.2     2021-12-06 [2] RSPM (R 4.4.0)\n##   shiny                     1.9.1     2024-08-01 [2] RSPM (R 4.4.0)\n##   SingleCellExperiment      1.27.2    2024-05-24 [2] Bioconductor 3.20 (R 4.4.0)\n##   sitmo                     2.0.2     2021-10-13 [2] RSPM (R 4.4.0)\n##   snow                      0.4-4     2021-10-27 [2] RSPM (R 4.4.0)\n##   sourcetools               0.1.7-1   2023-02-01 [2] RSPM (R 4.4.0)\n##   SparseArray               1.5.39    2024-09-23 [2] Bioconductor 3.20 (R 4.4.1)\n##   spatial                   7.3-17    2023-07-20 [3] CRAN (R 4.4.1)\n##   SpatialExperiment         1.15.1    2024-06-20 [2] Bioconductor 3.20 (R 4.4.0)\n##   splines                   4.4.1     2024-08-09 [3] local\n##   statmod                   1.5.0     2023-01-06 [2] RSPM (R 4.4.0)\n##   stats                   * 4.4.1     2024-08-09 [3] local\n##   stats4                    4.4.1     2024-08-09 [3] local\n##   STexampleData             1.13.3    2024-05-21 [2] Bioconductor 3.20 (R 4.4.0)\n##   stringi                   1.8.4     2024-05-06 [2] RSPM (R 4.4.0)\n##   stringr                   1.5.1     2023-11-14 [2] RSPM (R 4.4.0)\n##   SummarizedExperiment      1.35.1    2024-06-28 [2] Bioconductor 3.20 (R 4.4.1)\n##   survival                  3.7-0     2024-06-05 [2] RSPM (R 4.4.0)\n##   sys                       3.4.2     2023-05-23 [2] RSPM (R 4.4.0)\n##   systemfonts               1.1.0     2024-05-15 [2] RSPM (R 4.4.0)\n##   tcltk                     4.4.1     2024-08-09 [3] local\n##   testthat                  3.2.1.1   2024-04-14 [2] RSPM (R 4.4.0)\n##   textshaping               0.4.0     2024-05-24 [2] RSPM (R 4.4.0)\n##   tibble                    3.2.1     2023-03-20 [2] RSPM (R 4.4.0)\n##   tidyr                     1.3.1     2024-01-24 [2] RSPM (R 4.4.0)\n##   tidyselect                1.2.1     2024-03-11 [2] RSPM (R 4.4.0)\n##   tinytex                   0.53      2024-09-15 [2] RSPM (R 4.4.0)\n##   tools                     4.4.1     2024-08-09 [3] local\n##   UCSC.utils                1.1.0     2024-05-01 [2] Bioconductor 3.20 (R 4.4.0)\n##   urlchecker                1.0.1     2021-11-30 [2] RSPM (R 4.4.0)\n##   usethis                   3.0.0     2024-07-29 [2] RSPM (R 4.4.0)\n##   utf8                      1.2.4     2023-10-22 [2] RSPM (R 4.4.0)\n##   utils                   * 4.4.1     2024-08-09 [3] local\n##   uwot                      0.2.2     2024-04-21 [2] RSPM (R 4.4.0)\n##   vctrs                     0.6.5     2023-12-01 [2] RSPM (R 4.4.0)\n##   vipor                     0.4.7     2023-12-18 [2] RSPM (R 4.4.0)\n##   viridis                   0.6.5     2024-01-29 [2] RSPM (R 4.4.0)\n##   viridisLite               0.4.2     2023-05-02 [2] RSPM (R 4.4.0)\n##   waldo                     0.5.3     2024-08-23 [2] RSPM (R 4.4.0)\n##   whisker                   0.4.1     2022-12-05 [2] RSPM (R 4.4.0)\n##   withr                     3.0.1     2024-07-31 [2] RSPM (R 4.4.0)\n##   xfun                      0.47      2024-08-17 [2] RSPM (R 4.4.0)\n##   xml2                      1.3.6     2023-12-04 [2] RSPM (R 4.4.0)\n##   xopen                     1.0.1     2024-04-25 [2] RSPM (R 4.4.0)\n##   xtable                    1.8-4     2019-04-21 [2] RSPM (R 4.4.0)\n##   XVector                   0.45.0    2024-05-01 [2] Bioconductor 3.20 (R 4.4.0)\n##   yaml                      2.3.10    2024-07-26 [2] RSPM (R 4.4.0)\n##   zip                       2.3.1     2024-01-27 [2] RSPM (R 4.4.0)\n##   zlibbioc                  1.51.1    2024-06-05 [2] Bioconductor 3.20 (R 4.4.0)\n##  \n##   [1] /tmp/RtmpDJs1sE/Rinst8c761caaac\n##   [2] /usr/local/lib/R/site-library\n##   [3] /usr/local/lib/R/library\n##  \n##  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "pages/introduction.html",
    "href": "pages/introduction.html",
    "title": "1¬† Introduction",
    "section": "",
    "text": "1.1 Overview\nThis book provides discussion and interactive examples on best practices for computational analysis workflows for spatial transcriptomics data, using the Bioconductor framework within R.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "pages/introduction.html#contents",
    "href": "pages/introduction.html#contents",
    "title": "1¬† Introduction",
    "section": "1.2 Contents",
    "text": "1.2 Contents\nThe chapters are organized into several parts:\n\nIntroduction: introduction, background on spatial transcriptomics, and R/Bioconductor data classes\nAnalysis steps: individual analysis steps\nWorkflows: examples of complete analysis workflows\nAppendix: related resources, acknowledgments, and references",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "pages/introduction.html#scope-and-who-this-book-is-for",
    "href": "pages/introduction.html#scope-and-who-this-book-is-for",
    "title": "1¬† Introduction",
    "section": "1.3 Scope and who this book is for",
    "text": "1.3 Scope and who this book is for\nThe aim of this book is to demonstrate best practices for computational analysis workflows for spatial transcriptomics data through interactive examples and discussion using R code and example datasets. We assume some familiarity with R programming and an understanding of the types of biological questions that single-cell and spatial transcriptomics can be used to answer. Previous experience with Bioconductor is not required. By working through the examples in this book, readers will be able to adapt or extend the example workflows to analyze their own data.\nIn general, we focus on downstream analysis methods, which start with a gene expression count table and spatial coordinates as the main inputs. Preprocessing procedures to generate gene expression count tables are covered in other resources (e.g.¬†our related book Visium Data Preprocessing for data from the 10x Genomics Visium platform) and tutorials provided by the manufacturers of the technological platforms. For molecule-based platforms, we will usually use data that has been aggregated to the cell level.\nFor analysis steps where a number of different methods are available, we will showcase examples of methods that we have found to work well and are computationally scalable, with a preference for methods available through Bioconductor.\nAll methods used in this book are available through Bioconductor or CRAN (in R) or PyPI (in Python) to ensure installability and long-term maintenance. We also mention a number of additional methods that are available as packages from GitHub, but these are not run within the code examples.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "pages/introduction.html#bioconductor",
    "href": "pages/introduction.html#bioconductor",
    "title": "1¬† Introduction",
    "section": "1.4 Bioconductor",
    "text": "1.4 Bioconductor\nBioconductor is an ‚Äòopen source and open development‚Äô project providing a cohesive and flexible framework for rigorous and reproducible analyses of high-throughput genomic data in R (Huber et al. 2015). Bioconductor provides access to more than 2,000 contributed R packages, as well as infrastructure maintained by the Bioconductor Core Team, providing a rich analysis environment for users.\nA key strength of the Bioconductor framework is the modularity and open development philosophy. R packages are contributed by numerous research groups around the world, with the Bioconductor Core Team coordinating the overall project and maintaining infrastructure, build testing, and development guidelines. Contributed packages use consistent data structures, enabling users to connect packages developed by different groups to build analysis workflows that include the latest state-of-the-art methods. Bioconductor packages also include comprehensive documentation, including long-form tutorials or package vignettes.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "pages/introduction.html#additional-resources",
    "href": "pages/introduction.html#additional-resources",
    "title": "1¬† Introduction",
    "section": "1.5 Additional resources",
    "text": "1.5 Additional resources\nFor readers who are new to R and Bioconductor, additional useful resources include:\n\nThe Orchestrating Single-Cell Analysis with Bioconductor (OSCA) online book (Amezquita et al. 2020), which contains comprehensive materials on analysis workflows for non-spatial single-cell data as well as further introductory materials on R and Bioconductor.\nThe R for Data Science online book provides an excellent introduction to R.\nData Carpentry and Software Carpentry provide online lesson materials on R programming, the Unix shell, and version control.\nThe R/Bioconductor Data Science Team at the Lieber Institute for Brain Development has a detailed guide of free resources and videos to learn more about R and Bioconductor, as well as YouTube videos, including some on the basics of Bioconductor and infrastructure for storing gene expression data.\nThe Visium Data Preprocessing online book provides details on data preprocessing procedures for spatial transcriptomics data from the 10x Genomics Visium platform.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "pages/introduction.html#contributions",
    "href": "pages/introduction.html#contributions",
    "title": "1¬† Introduction",
    "section": "1.6 Contributions",
    "text": "1.6 Contributions\nWe welcome suggestions for updates and additions to the book. Suggestions may be provided as GitHub issues for further discussion with the maintainers.\nNote that all methods to be run within code examples must be available as either R packages from Bioconductor or CRAN, or Python packages from PyPI. This restriction provides readers with guarantees regarding installability, long-term availability, maintenance, and compatibility. Packages that are only available from GitHub or other repositories may be discussed within the text, but will not be included in the code examples. In general, our philosophy is to showcase examples of analysis methods that we have found to work well, are computationally scalable, user-friendly, and which can be integrated into existing Bioconductor-based workflows.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "pages/introduction.html#references",
    "href": "pages/introduction.html#references",
    "title": "1¬† Introduction",
    "section": "References",
    "text": "References\n\n\n\n\nAmezquita, Robert A., Aaron T. L. Lun, Etienne Becht, Vince J. Carey, Lindsay N. Carpp, Ludwig Geistlinger, Federico Marini, et al. 2020. ‚ÄúOrchestrating Single-Cell Analysis with Bioconductor.‚Äù Nature Methods 17: 137‚Äì45. https://doi.org/10.1038/s41592-019-0654-x.\n\n\nHuber, Wolfgang, Vincent J. Carey, Robert Gentleman, Simon Anders, Marc Carlson, Benilton S. Carvalho, Hector Corrada Bravo, et al. 2015. ‚ÄúOrchestrating High-Throughput Genomic Analysis with Bioconductor.‚Äù Nature Methods 12: 115‚Äì21. https://doi.org/10.1038/nmeth.3252.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "pages/spatial-transcriptomics.html",
    "href": "pages/spatial-transcriptomics.html",
    "title": "2¬† Spatial transcriptomics",
    "section": "",
    "text": "2.1 Overview\nSpatial transcriptomics (or spatially-resolved transcriptomics) refers to high-throughput genomic technological platforms that enable the measurement of high-dimensional gene expression at spatial resolution. Depending on the platform, this can include up to transcriptome-scale gene expression at up to thousands of measurement locations per tissue sample, usually on two-dimensional tissue sections. Spatially-resolved transcriptomics was named the Method of the Year 2020 by Nature Methods, and has found widespread application in numerous biological systems.\nA number of technological platforms have been developed, using a wide variety of technologies and experimental procedures. Platforms vary widely in terms of gene coverage, spatial resolution, and sensitivity and specificity. For users deciding between platforms, the tradeoff between gene coverage and spatial resolution is often a key consideration.\nPlatforms may be grouped into ‚Äòsequencing-based‚Äô and ‚Äòmolecule-based‚Äô (or ‚Äòimaging-based‚Äô) platforms, which are described in more detail below. In general, sequencing-based platforms provide higher gene coverage (up to transcriptome-scale, i.e.¬†thousands of genes), while molecule-based platforms provide higher spatial resolution (single-cell or sub-cellular resolution).\nIn this book, we focus on data from commercially available platforms, since these are the most accessible and widely used platforms. In this chapter, we provide a short overview and links to additional information on several key platforms.\nFor more in-depth background, several recent reviews are available, e.g. Bressan, Battistoni, and Hannon (2023) and Moses and Pachter (2022), which discuss available technological platforms, computational analysis methods, outstanding challenges, and additional topics.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Spatial transcriptomics</span>"
    ]
  },
  {
    "objectID": "pages/spatial-transcriptomics.html#sequencing-based-platforms",
    "href": "pages/spatial-transcriptomics.html#sequencing-based-platforms",
    "title": "2¬† Spatial transcriptomics",
    "section": "\n2.2 Sequencing-based platforms",
    "text": "2.2 Sequencing-based platforms\nSequencing-based platforms capture messenger RNA (mRNA) molecules at a set of spatial measurement locations on a tissue section placed on a slide, tag the mRNAs with unique spatial barcodes for each measurement location, and generate a readout by sequencing.\nThese platforms can provide full-transcriptome gene coverage (i.e.¬†&gt;10,000 genes) due to the use of sequencing, which does not require pre-selection of genes of interest. The spatial resolution varies between platforms, and depends on the size and spacing between the spatial capture locations. However, depending on the spatial resolution and tissue cell density, each spatial location may contain measurements from one or more cells, and capture locations may or may not overlap with individual cells, so these platforms generally do not provide single-cell spatial resolution.\nSpatial measurement locations for sequencing-based platforms are often referred to as ‚Äòspots‚Äô or ‚Äòbeads‚Äô. In this book, we will usually use the terminology ‚Äòspots‚Äô.\n\n2.2.1 10x Genomics Visium\nThe 10x Genomics Visium platform measures transcriptome-scale gene expression at a grid of spatial locations (referred to as spots) on a tissue capture area on a slide. Either fresh-frozen or formalin-fixed paraffin-embedded (FFPE) tissue may be used. Each spot contains millions of spatially-barcoded capture oligonucleotides, which bind to mRNAs from the tissue. A cDNA library is then generated for sequencing, which includes the spatial barcodes, allowing reads to be mapped back to their spatial locations.\nThe array dimensions are 6.5 x 6.5 mm, with around 5,000 barcoded spots. Spots are 55 ¬µm in diameter and spaced 100 ¬µm center-to-center in a hexagonal grid arrangement. The number of cells overlapping with each spot depends on the tissue cell density, e.g.¬†around 0-10 for human brain tissue or ~50 for mouse brain tissue. Each Visium slide contains four tissue capture areas. The following figure provides an illustration.\nHistology images generated from hematoxylin and eosin (H&E) staining can be used to identify anatomical and cell morphological features for each sample, including the number of cells per spot.\nThe 10x Genomics Visium platform is based on the original technological implementation developed by St√•hl et al. (2016).\n\n\n\n\nSchematic illustrating the 10x Genomics Visium platform. Source: 10x Genomics Visium\n\n\n\n\n2.2.2 10x Genomics Visium HD\nThe 10x Genomics Visium HD platform provides higher spatial resolution. Capture area dimensions are 6.5 x 6.5 mm, with a continuous lawn of capture oligonucleotides arranged into a grid of 2 x 2 ¬µm barcoded squares, which are also aggregated into 8 x 8 ¬µm and 16 x 16 ¬µm bins for downstream analyses. There are no gaps between the squares, and there are two capture areas per slide. The high spatial resolution of the barcoded squares provide near-single-cell resolution, while the use of sequencing provides transcriptome-scale gene coverage.\nA preprint describing the platform applied to human colorectal cancer samples is available from 10x Genomics (Oliveira et al. 2024).\n\n2.2.3 Curio Seeker\nThe Curio Seeker platform is a commercially available implementation and extension of the original Slide-seqV2 (Stickels et al. 2021) platform.\nThe Curio Seeker platform captures mRNA molecules at a set of randomly placed measurement locations (referred to as ‚Äòbeads‚Äô) on a tissue slide (referred to as a ‚Äòtile‚Äô) at high spatial resolution. The tile dimensions are 3 mm x 3 mm, and the spatial resolution consists of tightly packed 10 ¬µm diameter beads.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Spatial transcriptomics</span>"
    ]
  },
  {
    "objectID": "pages/spatial-transcriptomics.html#molecule-based-platforms",
    "href": "pages/spatial-transcriptomics.html#molecule-based-platforms",
    "title": "2¬† Spatial transcriptomics",
    "section": "\n2.3 Molecule-based platforms",
    "text": "2.3 Molecule-based platforms\nMolecule-based (or imaging-based) platforms identify the spatial locations of individual RNA molecules by sequential in situ hybridization (ISH) or by in situ sequencing (ISS), for targeted sets of up to hundreds or thousands of genes at single-cell or sub-cellular spatial resolution.\nImage segmentation is used to identify the boundaries of individual cells and assign RNA molecules to cells or nuclei during preprocessing. For downstream analyses, gene counts may be aggregated to the cell level, or analyses may be performed directly at the molecule level. Cell-level analyses can re-use methods developed for spot-level spatial transcriptomics data or single-cell data, while molecule-level analyses may require new methods.\nThe selection of targeted sets of biologically informative genes for an experiment, referred to as panel design, is a key consideration during experimental design. Several commercially available options for targeted gene sets suitable for certain biological systems are available.\n\n2.3.1 10x Genomics Xenium\nDetails on the 10x Genomics Xenium platform are available from 10x Genomics.\n\n2.3.2 Vizgen MERSCOPE\nDetails on the Vizgen MERSCOPE platform are available from Vizgen.\n\n2.3.3 NanoString CosMx\nDetails on the NanoString CosMx platform are available from NanoString.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Spatial transcriptomics</span>"
    ]
  },
  {
    "objectID": "pages/spatial-transcriptomics.html#references",
    "href": "pages/spatial-transcriptomics.html#references",
    "title": "2¬† Spatial transcriptomics",
    "section": "References",
    "text": "References\n\n\n\n\nBressan, Dario, Giorgia Battistoni, and Gregory J. Hannon. 2023. ‚ÄúThe Dawn of Spatial Omics.‚Äù Science 381 (6657). https://doi.org/10.1126/science.abq4964.\n\n\nMoses, Lambda, and Lior Pachter. 2022. ‚ÄúMuseum of Spatial Transcriptomics.‚Äù Nature Methods 19: 534‚Äì46. https://doi.org/10.1038/s41592-022-01409-2.\n\n\nOliveira, Michelli F., Juan P. Romero, Meii Chung, Stephen Williams, Andrew D. Gottscho, Anushka Gupta, Susan E. Pilipauskas, et al. 2024. ‚ÄúCharacterization of Immune Cell Populations in the Tumor Microenvironment of Colorectal Cancer Using High Definition Spatial Profiling.‚Äù bioRxiv. https://doi.org/10.1101/2024.06.04.597233.\n\n\nSt√•hl, Patrik L., Fredrik Salm√©n, Sanja Vickovic, Anna Lundmark, Jos√© Fern√°ndez Navarro, Jens Magnusson, Stefania Giacomello, et al. 2016. ‚ÄúVisualization and Analysis of Gene Expression in Tissue Sections by Spatial Transcriptomics.‚Äù Science 353 (6294): 78‚Äì82. https://doi.org/10.1126/science.aaf2403.\n\n\nStickels, Robert R., Evan Murray, Pawan Kumar, Jilong Li, Jamie L. Marshall, Daniela J. Di Bella, Paola Arlotta, Evan Z. Macosko, and Fei Chen. 2021. ‚ÄúHighly Sensitive Spatial Transcriptomics at Near-Cellular Resolution with Slide-seqV2.‚Äù Nature Biotechnology 39: 313‚Äì19. https://doi.org/10.1038/s41587-020-0739-1.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Spatial transcriptomics</span>"
    ]
  },
  {
    "objectID": "pages/bioconductor-data-classes.html",
    "href": "pages/bioconductor-data-classes.html",
    "title": "3¬† Bioconductor data classes",
    "section": "",
    "text": "3.1 Overview\nBioconductor provides several data classes for storing and manipulating spatial transcriptomics datasets. By relying on these standardized data structures, we can build analysis workflows that can easily connect methods and packages developed by different research groups.\nBelow, we describe the Bioconductor data classes used in this book.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Bioconductor data classes</span>"
    ]
  },
  {
    "objectID": "pages/bioconductor-data-classes.html#spatialexperiment-class",
    "href": "pages/bioconductor-data-classes.html#spatialexperiment-class",
    "title": "3¬† Bioconductor data classes",
    "section": "\n3.2 SpatialExperiment class",
    "text": "3.2 SpatialExperiment class\nThe SpatialExperiment class (Righelli et al. 2022) is the core data class that we use in this book. This class allows us to store datasets at the spot or cell level, i.e.¬†data from sequencing-based platforms (e.g.¬†10x Genomics Visium) at the spot level, or data from molecule-based platforms that has been aggregated to the cell level.\nSpatialExperiment builds on the SingleCellExperiment class (Amezquita et al. 2020) for single-cell RNA sequencing data, with additional customizations to store spatial information, such as spatial coordinates and image files.\nA summary of the SpatialExperiment object structure is shown in the following schematic. Briefly, a SpatialExperiment object consists of (i) assays containing expression counts, (ii) rowData containing information on features, i.e.¬†genes, (iii) colData containing information on spots or cells, including nonspatial and spatial metadata, (iv) spatialCoords containing spatial coordinates, and (v) imgData containing image data. For spot-based data (e.g.¬†10x Genomics Visium), a single assay named counts is used.\nFor more details, see the SpatialExperiment package Bioconductor vignette or the paper describing the class (Righelli et al. 2022).\n\n\n\n\nOverview of the SpatialExperiment data class for storing and manipulating spatial transcriptomics datasets within the Bioconductor framework.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Bioconductor data classes</span>"
    ]
  },
  {
    "objectID": "pages/bioconductor-data-classes.html#molecule-based-data",
    "href": "pages/bioconductor-data-classes.html#molecule-based-data",
    "title": "3¬† Bioconductor data classes",
    "section": "\n3.3 Molecule-based data",
    "text": "3.3 Molecule-based data\nMolecule-based spatial transcriptomics datasets contain additional information, including the spatial coordinates of individual mRNA molecules and segmentation boundaries for cells or nuclei.\nThe following Bioconductor classes provide additional functionality to store and manipulate this information.\nThese classes extend SpatialExperiment and are compatible with SpatialExperiment for analyses at the aggregated cell level.\n\n3.3.1 MoleculeExperiment\nMoleculeExperiment is available as a Bioconductor package and described by the authors in their paper (Peters Couto et al. 2023).\n\n3.3.2 SpatialFeatureExperiment\nSpatialFeatureExperiment is available as a Bioconductor package and described by the authors in their paper (Moses et al. 2023).",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Bioconductor data classes</span>"
    ]
  },
  {
    "objectID": "pages/bioconductor-data-classes.html#references",
    "href": "pages/bioconductor-data-classes.html#references",
    "title": "3¬† Bioconductor data classes",
    "section": "References",
    "text": "References\n\n\n\n\nAmezquita, Robert A., Aaron T. L. Lun, Etienne Becht, Vince J. Carey, Lindsay N. Carpp, Ludwig Geistlinger, Federico Marini, et al. 2020. ‚ÄúOrchestrating Single-Cell Analysis with Bioconductor.‚Äù Nature Methods 17: 137‚Äì45. https://doi.org/10.1038/s41592-019-0654-x.\n\n\nMoses, Lambda, P√©tur Helgi Einarsson, Kayla Jackson, Laura Luebbert, A. Sina Booeshaghi, Sindri Antonsson, Nicolas Bray, P√°ll Melsted, and Lior Pachter. 2023. ‚ÄúVoyager: Exploratory Single-Cell Genomics Data Analysis with Geospatial Statistics.‚Äù bioRxiv. https://doi.org/10.1101/2023.07.20.549945.\n\n\nPeters Couto, B√°rbara Zita, Nicholas Robertson, Ellis Patrick, and Shila Ghazanfar. 2023. ‚ÄúMoleculeExperiment Enables Consistent Infrastructure for Molecule-Resolved Spatial Transcriptomics Data in Bioconductor.‚Äù bioRxiv. https://doi.org/10.1101/2023.05.16.541040.\n\n\nRighelli, Dario, Lukas M. Weber, Helena L. Crowell, Brenda Pardo, Leonardo Collado-Torres, Shila Ghazanfar, Aaron T. L. Lun, Stephanie C. Hicks, and Davide Risso. 2022. ‚ÄúSpatialExperiment: Infrastructure for Spatially-Resolved Transcriptomics Data in R Using Bioconductor.‚Äù Bioinformatics 38 (11): 3128‚Äì31. https://doi.org/10.1093/bioinformatics/btac299.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Bioconductor data classes</span>"
    ]
  },
  {
    "objectID": "pages/analysis-steps.html",
    "href": "pages/analysis-steps.html",
    "title": "4¬† Analysis steps",
    "section": "",
    "text": "4.1 Save data objects for re-use in later chapters\nBelow, we also run some code to generate data objects that will be re-used in the later chapters, in order to speed up the build time for the online version of the book.\nAll code below is also shown in later chapters, so this section can be skipped when reading the book.",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Analysis steps</span>"
    ]
  },
  {
    "objectID": "pages/analysis-steps.html#save-data-objects-for-re-use-in-later-chapters",
    "href": "pages/analysis-steps.html#save-data-objects-for-re-use-in-later-chapters",
    "title": "4¬† Analysis steps",
    "section": "",
    "text": "4.1.1 Human DLPFC dataset\n\n# LOAD DATA\n\nlibrary(SpatialExperiment)\nlibrary(STexampleData)\nspe &lt;- Visium_humanDLPFC()\n\n# save object\nsaveRDS(spe, file = \"spe_load.rds\")\n\n\n# QUALITY CONTROL (QC)\n\nlibrary(scater)\n# subset to keep only spots over tissue\nspe &lt;- spe[, colData(spe)$in_tissue == 1]\n# identify mitochondrial genes\nis_mito &lt;- grepl(\"(^MT-)|(^mt-)\", rowData(spe)$gene_name)\n# calculate per-spot QC metrics\nspe &lt;- addPerCellQC(spe, subsets = list(mito = is_mito))\n# select QC thresholds\nqc_lib_size &lt;- colData(spe)$sum &lt; 600\nqc_detected &lt;- colData(spe)$detected &lt; 400\nqc_mito &lt;- colData(spe)$subsets_mito_percent &gt; 28\nqc_cell_count &lt;- colData(spe)$cell_count &gt; 10\n# combined set of discarded spots\ndiscard &lt;- qc_lib_size | qc_detected | qc_mito | qc_cell_count\ncolData(spe)$discard &lt;- discard\n# filter low-quality spots\nspe &lt;- spe[, !colData(spe)$discard]\n\n# save object\nsaveRDS(spe, file = \"spe_qc.rds\")\n\n\n# NORMALIZATION\n\nlibrary(scran)\n# calculate logcounts using library size factors\nspe &lt;- logNormCounts(spe)\n\n# save object\nsaveRDS(spe, file = \"spe_logcounts.rds\")\n\n\n# FEATURE SELECTION\n\n# remove mitochondrial genes\nspe &lt;- spe[!is_mito, ]\n# fit mean-variance relationship\ndec &lt;- modelGeneVar(spe)\n# select top HVGs\ntop_hvgs &lt;- getTopHVGs(dec, prop = 0.1)\n\n# save object\nsaveRDS(spe, file = \"spe_hvgs.rds\")\nsaveRDS(top_hvgs, file = \"top_hvgs.rds\")\n\n\n# DIMENSIONALITY REDUCTION\n\n# compute PCA\nset.seed(123)\nspe &lt;- runPCA(spe, subset_row = top_hvgs)\n# compute UMAP on top 50 PCs\nset.seed(123)\nspe &lt;- runUMAP(spe, dimred = \"PCA\")\n# update column names\ncolnames(reducedDim(spe, \"UMAP\")) &lt;- paste0(\"UMAP\", 1:2)\n\n# save object\nsaveRDS(spe, file = \"spe_reduceddims.rds\")\n\n\n# CLUSTERING\n\n# graph-based clustering\nset.seed(123)\nk &lt;- 10\ng &lt;- buildSNNGraph(spe, k = k, use.dimred = \"PCA\")\ng_walk &lt;- igraph::cluster_walktrap(g)\nclus &lt;- g_walk$membership\ncolLabels(spe) &lt;- factor(clus)\n\n# save object\nsaveRDS(spe, file = \"spe_cluster.rds\")",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Analysis steps</span>"
    ]
  },
  {
    "objectID": "pages/analysis-steps.html#references",
    "href": "pages/analysis-steps.html#references",
    "title": "4¬† Analysis steps",
    "section": "References",
    "text": "References",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Analysis steps</span>"
    ]
  },
  {
    "objectID": "pages/load-data.html",
    "href": "pages/load-data.html",
    "title": "5¬† Load data",
    "section": "",
    "text": "5.1 Overview\nIn the following chapters, we apply analysis methods to spatial transcriptomics datasets that are formatted as SpatialExperiment objects or objects from other Bioconductor data classes (see Chapter 3).\nHere, we load a 10x Genomics Visium dataset that will be used in several of the following chapters.\nThis dataset has previously been preprocessed using data preprocessing procedures with tools outside R and saved in SpatialExperiment format. For more details on data preprocessing procedures for the 10x Genomics Visium platform, see the related online book Visium Data Preprocessing.\nThis dataset is available for download in SpatialExperiment format from the STexampleData Bioconductor package.",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Load data</span>"
    ]
  },
  {
    "objectID": "pages/load-data.html#dataset",
    "href": "pages/load-data.html#dataset",
    "title": "5¬† Load data",
    "section": "\n5.2 Dataset",
    "text": "5.2 Dataset\nThis dataset consists of one sample (Visium capture area) from one donor, consisting of postmortem human brain tissue from the dorsolateral prefrontal cortex (DLPFC) brain region, measured with the 10x Genomics Visium platform. The dataset is described in the original publication by Maynard et al. (2021).\nMore details on the dataset are also included in ?sec-workflow-human-dlpfc.",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Load data</span>"
    ]
  },
  {
    "objectID": "pages/load-data.html#load-data",
    "href": "pages/load-data.html#load-data",
    "title": "5¬† Load data",
    "section": "\n5.3 Load data",
    "text": "5.3 Load data\nDownload and load the dataset in SpatialExperiment format from the STexampleData Bioconductor package.\n\nlibrary(SpatialExperiment)\nlibrary(STexampleData)\n\n# load object\nspe &lt;- Visium_humanDLPFC()",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Load data</span>"
    ]
  },
  {
    "objectID": "pages/load-data.html#spatialexperiment-object",
    "href": "pages/load-data.html#spatialexperiment-object",
    "title": "5¬† Load data",
    "section": "\n5.4 SpatialExperiment object",
    "text": "5.4 SpatialExperiment object\nCheck the structure of the SpatialExperiment object. For more details on the SpatialExperiment structure, see Chapter 3.\n\n# check object\nspe\n##  class: SpatialExperiment \n##  dim: 33538 4992 \n##  metadata(0):\n##  assays(1): counts\n##  rownames(33538): ENSG00000243485 ENSG00000237613 ... ENSG00000277475\n##    ENSG00000268674\n##  rowData names(3): gene_id gene_name feature_type\n##  colnames(4992): AAACAACGAATAGTTC-1 AAACAAGTATCTCCCA-1 ...\n##    TTGTTTGTATTACACG-1 TTGTTTGTGTAAATTC-1\n##  colData names(8): barcode_id sample_id ... reference cell_count\n##  reducedDimNames(0):\n##  mainExpName: NULL\n##  altExpNames(0):\n##  spatialCoords names(2) : pxl_col_in_fullres pxl_row_in_fullres\n##  imgData names(4): sample_id image_id data scaleFactor\n\n# number of genes (rows) and spots (columns)\ndim(spe)\n##  [1] 33538  4992\n\n# names of 'assays'\nassayNames(spe)\n##  [1] \"counts\"\n\n# row (gene) data\nhead(rowData(spe))\n##  DataFrame with 6 rows and 3 columns\n##                          gene_id   gene_name    feature_type\n##                      &lt;character&gt; &lt;character&gt;     &lt;character&gt;\n##  ENSG00000243485 ENSG00000243485 MIR1302-2HG Gene Expression\n##  ENSG00000237613 ENSG00000237613     FAM138A Gene Expression\n##  ENSG00000186092 ENSG00000186092       OR4F5 Gene Expression\n##  ENSG00000238009 ENSG00000238009  AL627309.1 Gene Expression\n##  ENSG00000239945 ENSG00000239945  AL627309.3 Gene Expression\n##  ENSG00000239906 ENSG00000239906  AL627309.2 Gene Expression\n\n# column (spot) data\nhead(colData(spe))\n##  DataFrame with 6 rows and 8 columns\n##                             barcode_id     sample_id in_tissue array_row\n##                            &lt;character&gt;   &lt;character&gt; &lt;integer&gt; &lt;integer&gt;\n##  AAACAACGAATAGTTC-1 AAACAACGAATAGTTC-1 sample_151673         0         0\n##  AAACAAGTATCTCCCA-1 AAACAAGTATCTCCCA-1 sample_151673         1        50\n##  AAACAATCTACTAGCA-1 AAACAATCTACTAGCA-1 sample_151673         1         3\n##  AAACACCAATAACTGC-1 AAACACCAATAACTGC-1 sample_151673         1        59\n##  AAACAGAGCGACTCCT-1 AAACAGAGCGACTCCT-1 sample_151673         1        14\n##  AAACAGCTTTCAGAAG-1 AAACAGCTTTCAGAAG-1 sample_151673         1        43\n##                     array_col ground_truth   reference cell_count\n##                     &lt;integer&gt;  &lt;character&gt; &lt;character&gt;  &lt;integer&gt;\n##  AAACAACGAATAGTTC-1        16           NA          NA         NA\n##  AAACAAGTATCTCCCA-1       102       Layer3      Layer3          6\n##  AAACAATCTACTAGCA-1        43       Layer1      Layer1         16\n##  AAACACCAATAACTGC-1        19           WM          WM          5\n##  AAACAGAGCGACTCCT-1        94       Layer3      Layer3          2\n##  AAACAGCTTTCAGAAG-1         9       Layer5      Layer5          4\n\n# spatial coordinates\nhead(spatialCoords(spe))\n##                     pxl_col_in_fullres pxl_row_in_fullres\n##  AAACAACGAATAGTTC-1               3913               2435\n##  AAACAAGTATCTCCCA-1               9791               8468\n##  AAACAATCTACTAGCA-1               5769               2807\n##  AAACACCAATAACTGC-1               4068               9505\n##  AAACAGAGCGACTCCT-1               9271               4151\n##  AAACAGCTTTCAGAAG-1               3393               7583\n\n# image data\nimgData(spe)\n##  DataFrame with 2 rows and 4 columns\n##        sample_id    image_id   data scaleFactor\n##      &lt;character&gt; &lt;character&gt; &lt;list&gt;   &lt;numeric&gt;\n##  1 sample_151673      lowres   ####   0.0450045\n##  2 sample_151673       hires   ####   0.1500150",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Load data</span>"
    ]
  },
  {
    "objectID": "pages/load-data.html#build-object",
    "href": "pages/load-data.html#build-object",
    "title": "5¬† Load data",
    "section": "\n5.5 Build object",
    "text": "5.5 Build object\nAlternatively, we can also build a SpatialExperiment object directly from raw data.\nHere, we provide a short example with an empty dataset.\nFor more details, including how to load raw data from the 10x Genomics Space Ranger output files to build an object, or how to add image data to the object, see the SpatialExperiment documentation.\n\n# create data\nn_genes &lt;- 200\nn_spots &lt;- 100\n\ncounts &lt;- matrix(0, nrow = n_genes, ncol = n_spots)\n\nrow_data &lt;- DataFrame(\n  gene_name = paste0(\"gene\", sprintf(\"%03d\", seq_len(n_genes)))\n)\n\ncol_data &lt;- DataFrame(\n  sample_id = rep(\"sample01\", n_spots)\n)\n\nspatial_coords &lt;- matrix(0, nrow = n_spots, ncol = 2)\ncolnames(spatial_coords) &lt;- c(\"x\", \"y\")\n\n# create SpatialExperiment object\nspe &lt;- SpatialExperiment(\n  assays = list(counts = counts), \n  colData = col_data, \n  rowData = row_data, \n  spatialCoords = spatial_coords\n)",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Load data</span>"
    ]
  },
  {
    "objectID": "pages/load-data.html#molecule-based-data",
    "href": "pages/load-data.html#molecule-based-data",
    "title": "5¬† Load data",
    "section": "\n5.6 Molecule-based data",
    "text": "5.6 Molecule-based data\nFor more details on data classes for molecule-based platforms, e.g.¬†10x Genomics Xenium or Vizgen MERSCOPE, see Chapter 3.",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Load data</span>"
    ]
  },
  {
    "objectID": "pages/load-data.html#references",
    "href": "pages/load-data.html#references",
    "title": "5¬† Load data",
    "section": "References",
    "text": "References\n\n\n\n\nMaynard, Kristen R., Leonardo Collado-Torres, Lukas M. Weber, Cedric Uytingco, Brianna K. Barry, Stephen R. Williams, Joseph L. Catallini II, et al. 2021. ‚ÄúTranscriptome-Scale Spatial Gene Expression in the Human Dorsolateral Prefrontal Cortex.‚Äù Nature Neuroscience 24: 425‚Äì36. https://doi.org/10.1038/s41593-020-00787-0.",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Load data</span>"
    ]
  },
  {
    "objectID": "pages/quality-control.html",
    "href": "pages/quality-control.html",
    "title": "6¬† Quality control",
    "section": "",
    "text": "6.1 Overview\nQuality control (QC) procedures at the spot level aim to remove low-quality spots before further analysis. Low-quality spots can occur due to problems during library preparation or other experimental procedures. Examples include large proportions of dead cells due to cell damage during library preparation, and low mRNA capture efficiency due to inefficient reverse transcription or PCR amplification.\nThese spots are usually removed prior to further analysis, since otherwise they tend to create problems during downstream analyses such as clustering. For example, problematic spots that are not removed could show up as separate clusters, which may be misidentified as distinct cell types.\nLow-quality spots can be identified according to several characteristics, including:\nLow library size or low number of expressed features can indicate poor mRNA capture rates, e.g.¬†due to cell damage and missing mRNAs, or low reaction efficiency. A high proportion of mitochondrial reads indicates cell damage, e.g.¬†partial cell lysis leading to leakage and missing cytoplasmic mRNAs, with the resulting reads therefore concentrated on the remaining mitochondrial mRNAs that are relatively protected inside the mitochondrial membrane. Unusually high numbers of cells per spot can indicate problems during cell segmentation.\nThe first three characteristics listed above are also used for QC in scRNA-seq data. However, the expected distributions for high-quality spots are different (compared to high-quality cells in scRNA-seq), since spots may contain zero, one, or multiple cells.",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Quality control</span>"
    ]
  },
  {
    "objectID": "pages/quality-control.html#overview",
    "href": "pages/quality-control.html#overview",
    "title": "6¬† Quality control",
    "section": "",
    "text": "library size (i.e.¬†total UMI counts per spot)\nnumber of expressed features (i.e.¬†number of genes with non-zero UMI counts per spot)\nproportion of reads mapping to mitochondrial genes (a high proportion indicates cell damage)\nnumber of cells per spot (unusually high values can indicate problems)",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Quality control</span>"
    ]
  },
  {
    "objectID": "pages/quality-control.html#load-data-from-previous-steps",
    "href": "pages/quality-control.html#load-data-from-previous-steps",
    "title": "6¬† Quality control",
    "section": "\n6.2 Load data from previous steps",
    "text": "6.2 Load data from previous steps\nWe start by loading the data object(s) saved after running the analysis steps from the previous chapters. Code to re-run the previous steps is shown in condensed form in Chapter 4.\n\nlibrary(SpatialExperiment)\nspe &lt;- readRDS(\"spe_load.rds\")",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Quality control</span>"
    ]
  },
  {
    "objectID": "pages/quality-control.html#plot-data",
    "href": "pages/quality-control.html#plot-data",
    "title": "6¬† Quality control",
    "section": "\n6.3 Plot data",
    "text": "6.3 Plot data\nAs an initial check, plot the spatial coordinates (spots) in x-y dimensions on the tissue slide, to check that the object has loaded correctly and that the orientation is as expected.\nWe use visualization functions from the ggspavis package to generate plots.\n\nlibrary(ggspavis)\n\n\n# plot spatial coordinates (spots)\nplotSpots(spe)",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Quality control</span>"
    ]
  },
  {
    "objectID": "pages/quality-control.html#calculate-qc-metrics",
    "href": "pages/quality-control.html#calculate-qc-metrics",
    "title": "6¬† Quality control",
    "section": "\n6.4 Calculate QC metrics",
    "text": "6.4 Calculate QC metrics\nWe calculate the QC metrics described above with a combination of methods from the scater (McCarthy et al. 2017) package (for metrics that are also used for scRNA-seq data, where we treat spots as equivalent to cells) and our own functions.\nThe QC metrics from scater can be calculated and added to the SpatialExperiment object as follows. Here, we also identify mitochondrial reads using their gene names, and pass these as an argument to scater.\nFirst, we subset the object to keep only spots over tissue. The remaining spots are background spots, which we are not interested in.\n\nlibrary(scater)\n\n\n# subset to keep only spots over tissue\nspe &lt;- spe[, colData(spe)$in_tissue == 1]\ndim(spe)\n##  [1] 33538  3639\n\n\n# identify mitochondrial genes\nis_mito &lt;- grepl(\"(^MT-)|(^mt-)\", rowData(spe)$gene_name)\ntable(is_mito)\n##  is_mito\n##  FALSE  TRUE \n##  33525    13\nrowData(spe)$gene_name[is_mito]\n##   [1] \"MT-ND1\"  \"MT-ND2\"  \"MT-CO1\"  \"MT-CO2\"  \"MT-ATP8\" \"MT-ATP6\" \"MT-CO3\" \n##   [8] \"MT-ND3\"  \"MT-ND4L\" \"MT-ND4\"  \"MT-ND5\"  \"MT-ND6\"  \"MT-CYB\"\n\n# calculate per-spot QC metrics and store in colData\nspe &lt;- addPerCellQC(spe, subsets = list(mito = is_mito))\nhead(colData(spe))\n##  DataFrame with 6 rows and 14 columns\n##                             barcode_id     sample_id in_tissue array_row\n##                            &lt;character&gt;   &lt;character&gt; &lt;integer&gt; &lt;integer&gt;\n##  AAACAAGTATCTCCCA-1 AAACAAGTATCTCCCA-1 sample_151673         1        50\n##  AAACAATCTACTAGCA-1 AAACAATCTACTAGCA-1 sample_151673         1         3\n##  AAACACCAATAACTGC-1 AAACACCAATAACTGC-1 sample_151673         1        59\n##  AAACAGAGCGACTCCT-1 AAACAGAGCGACTCCT-1 sample_151673         1        14\n##  AAACAGCTTTCAGAAG-1 AAACAGCTTTCAGAAG-1 sample_151673         1        43\n##  AAACAGGGTCTATATT-1 AAACAGGGTCTATATT-1 sample_151673         1        47\n##                     array_col ground_truth   reference cell_count       sum\n##                     &lt;integer&gt;  &lt;character&gt; &lt;character&gt;  &lt;integer&gt; &lt;numeric&gt;\n##  AAACAAGTATCTCCCA-1       102       Layer3      Layer3          6      8458\n##  AAACAATCTACTAGCA-1        43       Layer1      Layer1         16      1667\n##  AAACACCAATAACTGC-1        19           WM          WM          5      3769\n##  AAACAGAGCGACTCCT-1        94       Layer3      Layer3          2      5433\n##  AAACAGCTTTCAGAAG-1         9       Layer5      Layer5          4      4278\n##  AAACAGGGTCTATATT-1        13       Layer6      Layer6          6      4004\n##                      detected subsets_mito_sum subsets_mito_detected\n##                     &lt;numeric&gt;        &lt;numeric&gt;             &lt;numeric&gt;\n##  AAACAAGTATCTCCCA-1      3586             1407                    13\n##  AAACAATCTACTAGCA-1      1150              204                    11\n##  AAACACCAATAACTGC-1      1960              430                    13\n##  AAACAGAGCGACTCCT-1      2424             1316                    13\n##  AAACAGCTTTCAGAAG-1      2264              651                    12\n##  AAACAGGGTCTATATT-1      2178              621                    13\n##                     subsets_mito_percent     total\n##                                &lt;numeric&gt; &lt;numeric&gt;\n##  AAACAAGTATCTCCCA-1              16.6351      8458\n##  AAACAATCTACTAGCA-1              12.2376      1667\n##  AAACACCAATAACTGC-1              11.4089      3769\n##  AAACAGAGCGACTCCT-1              24.2223      5433\n##  AAACAGCTTTCAGAAG-1              15.2174      4278\n##  AAACAGGGTCTATATT-1              15.5095      4004",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Quality control</span>"
    ]
  },
  {
    "objectID": "pages/quality-control.html#selecting-thresholds",
    "href": "pages/quality-control.html#selecting-thresholds",
    "title": "6¬† Quality control",
    "section": "\n6.5 Selecting thresholds",
    "text": "6.5 Selecting thresholds\nThe simplest option to apply the QC metrics is to select thresholds for each metric, and remove any spots that do not meet the thresholds for one or more metrics. Exploratory visualizations can be used to help select appropriate thresholds, which may differ depending on the dataset.\nHere, we use visualizations to select thresholds for several QC metrics in our human DLPFC dataset: (i) library size, (ii) number of expressed genes, (iii) proportion of mitochondrial reads, and (iv) number of cells per spot.\n\n6.5.1 Library size\nLibrary size represents the total sum of UMI counts per spot. This is included in the column labeled sum in the scater output.\nPlot a histogram of the library sizes across spots.\n\n# histogram of library sizes\nhist(colData(spe)$sum, breaks = 20)\n\n\n\n\n\n\n\nThe distribution is relatively smooth, and there are no obvious issue such as a spike at very low library sizes.\nWe also plot the library sizes against the number of cells per spot (which is available for this dataset). This is to check that we are not inadvertently removing a biologically meaningful group of spots. The horizontal line (argument threshold) shows our first guess at a possible filtering threshold for library size based on the histogram.\n\n# plot library size vs. number of cells per spot\nplotSpotQC(spe, plot_type = \"scatter\", \n           x_metric = \"cell_count\", y_metric = \"sum\", \n           y_threshold = 600)\n##  `geom_smooth()` using formula = 'y ~ x'\n##  `stat_xsidebin()` using `bins = 30`. Pick better value with `binwidth`.\n##  `stat_ysidebin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\nThe plot shows that setting a filtering threshold for library size (e.g.¬†at the value shown) does not appear to select for any obvious biologically consistent group of spots.\nWe set a relatively arbitrary threshold of 600 UMI counts per spot, and then check the number of spots below this threshold.\n\n# select QC threshold for library size\nqc_lib_size &lt;- colData(spe)$sum &lt; 600\ntable(qc_lib_size)\n##  qc_lib_size\n##  FALSE  TRUE \n##   3631     8\n\ncolData(spe)$qc_lib_size &lt;- qc_lib_size\n\nFinally, we also check that the discarded spots do not have any obvious spatial pattern that correlates with known biological features. Otherwise, removing these spots could indicate that we have set the threshold too high, and are removing biologically informative spots.\n\n# check spatial pattern of discarded spots\nplotSpotQC(spe, plot_type = \"spot\", \n           annotate = \"qc_lib_size\")\n\n\n\n\n\n\n\nAs an aside, here we can also illustrate what happens if we set the threshold too high. For example, if we set the threshold to 2000 UMI counts per spot ‚Äì which may also seem like a reasonable value based on the histogram and scatterplot ‚Äì then we see a possible spatial pattern in the discarded spots, matching the cortical layers. This illustrates the importance of interactively checking exploratory visualizations when choosing these thresholds.\n\n# check spatial pattern of discarded spots if threshold is too high\nqc_lib_size_2000 &lt;- colData(spe)$sum &lt; 2000\ncolData(spe)$qc_lib_size_2000 &lt;- qc_lib_size_2000\nplotSpotQC(spe, plot_type = \"spot\", \n           annotate = \"qc_lib_size_2000\")\n\n\n\n\n\n\n\nFor reference, here are the ground truth (manually annotated) cortical layers in this dataset.\n\n# plot ground truth (manually annotated) layers\nplotSpots(spe, annotate = \"ground_truth\", \n          pal = \"libd_layer_colors\")\n\n\n\n\n\n\n\n\n6.5.2 Number of expressed features\nThe number of expressed features refers to the number of genes with non-zero UMI counts per spot. This is stored in the column detected in the scater output.\nWe use a similar sequence of visualizations to choose a threshold for this QC metric.\n\n# histogram of numbers of expressed genes\nhist(colData(spe)$detected, breaks = 20)\n\n\n\n\n\n\n\n\n# plot number of expressed genes vs. number of cells per spot\nplotSpotQC(spe, plot_type = \"scatter\", \n           x_metric = \"cell_count\", y_metric = \"detected\", \n           y_threshold = 400)\n##  `geom_smooth()` using formula = 'y ~ x'\n##  `stat_xsidebin()` using `bins = 30`. Pick better value with `binwidth`.\n##  `stat_ysidebin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\nBased on the plots, we select a threshold of 400 expressed genes per spot.\n\n# select QC threshold for number of expressed genes\nqc_detected &lt;- colData(spe)$detected &lt; 400\ntable(qc_detected)\n##  qc_detected\n##  FALSE  TRUE \n##   3632     7\n\ncolData(spe)$qc_detected &lt;- qc_detected\n\n\n# check spatial pattern of discarded spots\nplotSpotQC(spe, plot_type = \"spot\", \n           annotate = \"qc_detected\")\n\n\n\n\n\n\n\nAgain, we also check what happens when we set the threshold too high.\n\n# check spatial pattern of discarded spots if threshold is too high\nqc_detected_1000 &lt;- colData(spe)$detected &lt; 1000\ncolData(spe)$qc_detected_1000 &lt;- qc_detected_1000\nplotSpotQC(spe, plot_type = \"spot\", \n           annotate = \"qc_detected_1000\")\n\n\n\n\n\n\n\n\n6.5.3 Proportion of mitochondrial reads\nA high proportion of mitochondrial reads indicates cell damage.\nWe investigate the proportions of mitochondrial reads across spots, and select an appropriate threshold. The proportions of mitochondrial reads per spot are stored in the column subsets_mito_percent in the scater output.\n\n# histogram of mitochondrial read proportions\nhist(colData(spe)$subsets_mito_percent, breaks = 20)\n\n\n\n\n\n\n\n\n# plot mitochondrial read proportion vs. number of cells per spot\nplotSpotQC(spe, plot_type = \"scatter\", \n           x_metric = \"cell_count\", y_metric = \"subsets_mito_percent\", \n           y_threshold = 28)\n##  `geom_smooth()` using formula = 'y ~ x'\n##  `stat_xsidebin()` using `bins = 30`. Pick better value with `binwidth`.\n##  `stat_ysidebin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\nWe select a threshold of 28% for the mitochondrial read proportion.\n\n# select QC threshold for mitochondrial read proportion\nqc_mito &lt;- colData(spe)$subsets_mito_percent &gt; 28\ntable(qc_mito)\n##  qc_mito\n##  FALSE  TRUE \n##   3622    17\n\ncolData(spe)$qc_mito &lt;- qc_mito\n\n\n# check spatial pattern of discarded spots\nplotSpotQC(spe, plot_type = \"spot\", \n           annotate = \"qc_mito\")\n\n\n\n\n\n\n\nWe also check what happens when we set the threshold too low.\n\n# check spatial pattern of discarded spots if threshold is too high\nqc_mito_25 &lt;- colData(spe)$subsets_mito_percent &gt; 25\ncolData(spe)$qc_mito_25 &lt;- qc_mito_25\nplotSpotQC(spe, plot_type = \"spot\", \n           annotate = \"qc_mito_25\")\n\n\n\n\n\n\n\n\n6.5.4 Number of cells per spot\nThe number of cells per spot depends on the tissue type and organism.\nHere, we check for any outlier values that could indicate problems during cell segmentation.\n\n# histogram of cell counts\nhist(colData(spe)$cell_count, breaks = 20)\n\n\n\n\n\n\n\n# distribution of cells per spot\ntbl_cells_per_spot &lt;- table(colData(spe)$cell_count)\n\nWe see a tail of very high values, which could indicate problems for these spots. These values are also visible on the scatterplots. Here, we again plot the number of expressed genes vs.¬†cell count, with an added trend.\n\n# plot number of expressed genes vs. number of cells per spot\nplotSpotQC(spe, plot_type = \"scatter\", \n           x_metric = \"cell_count\", y_metric = \"detected\", \n           x_threshold = 10)\n##  `geom_smooth()` using formula = 'y ~ x'\n##  `stat_xsidebin()` using `bins = 30`. Pick better value with `binwidth`.\n##  `stat_ysidebin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\nIn particular, we see that the spots with very high cell counts also have low numbers of expressed genes. This indicates that the experiments have failed for these spots, and they should be removed.\nWe select a threshold of 10 cells per spot. The number of spots above this threshold is relatively small, and there is a clear downward trend in the number of expressed genes above this threshold.\n\n# select QC threshold for number of cells per spot\nqc_cell_count &lt;- colData(spe)$cell_count &gt; 10\ntable(qc_cell_count)\n##  qc_cell_count\n##  FALSE  TRUE \n##   3549    90\n\ncolData(spe)$qc_cell_count &lt;- qc_cell_count\n\n\n# check spatial pattern of discarded spots\nplotSpotQC(spe, plot_type = \"spot\", \n           annotate = \"qc_cell_count\")\n\n\n\n\n\n\n\nWhile there is a spatial pattern to the discarded spots, it does not appear to be correlated with the known biological features (cortical layers). The discarded spots are all on the edges of the tissue. It seems plausible that something has gone wrong with the cell segmentation on the edges of the images, so it makes sense to remove these spots.\n\n6.5.5 Remove low-quality spots\nNow that we have calculated several QC metrics and selected thresholds for each one, we can combine the sets of low-quality spots, and remove them from our object.\nWe also check again that the combined set of discarded spots does not correspond to any obvious biologically relevant group of spots.\n\n# number of discarded spots for each metric\napply(cbind(qc_lib_size, qc_detected, qc_mito, qc_cell_count), 2, sum)\n##    qc_lib_size   qc_detected       qc_mito qc_cell_count \n##              8             7            17            90\n\n# combined set of discarded spots\ndiscard &lt;- qc_lib_size | qc_detected | qc_mito | qc_cell_count\ntable(discard)\n##  discard\n##  FALSE  TRUE \n##   3524   115\n\n# store in object\ncolData(spe)$discard &lt;- discard\n\n\n# check spatial pattern of combined set of discarded spots\nplotSpotQC(spe, plot_type = \"spot\", \n           annotate = \"discard\")\n\n\n\n\n\n\n\n\n# remove combined set of low-quality spots\nspe &lt;- spe[, !colData(spe)$discard]\ndim(spe)\n##  [1] 33538  3524",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Quality control</span>"
    ]
  },
  {
    "objectID": "pages/quality-control.html#zero-cell-and-single-cell-spots",
    "href": "pages/quality-control.html#zero-cell-and-single-cell-spots",
    "title": "6¬† Quality control",
    "section": "\n6.6 Zero-cell and single-cell spots",
    "text": "6.6 Zero-cell and single-cell spots\nA particular characteristic of Visium data is that spots can contain zero, one, or multiple cells.\nWe could also imagine other filtering procedures such as (i) removing spots with zero cells, or (ii) restricting the analysis to spots containing a single cell (which would make the data more similar to scRNA-seq).\nHowever, this would discard a large amount of information. Below, we show the distribution of cells per spot again (up to the filtering threshold of 10 cells per spot from above).\n\n# distribution of cells per spot\ntbl_cells_per_spot[1:13]\n##  \n##    0   1   2   3   4   5   6   7   8   9  10  11  12 \n##   84 211 483 623 617 541 421 287 140  92  50  25  18\n\n# as proportions\nprop_cells_per_spot &lt;- round(tbl_cells_per_spot / sum(tbl_cells_per_spot), 2)\nprop_cells_per_spot[1:13]\n##  \n##     0    1    2    3    4    5    6    7    8    9   10   11   12 \n##  0.02 0.06 0.13 0.17 0.17 0.15 0.12 0.08 0.04 0.03 0.01 0.01 0.00\n\nOnly 6% of spots contain a single cell. If we restricted the analysis to these spots only, we would be discarding most of the data.\nRemoving the spots containing zero cells (2% of spots) would also be problematic, since these spots can also contain biologically meaningful information. For example, in this brain dataset, the regions between cell bodies consists of neuropil (dense networks of axons and dendrites). In our paper (Maynard et al. 2021), we explore the information contained in these neuropil spots.",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Quality control</span>"
    ]
  },
  {
    "objectID": "pages/quality-control.html#quality-control-at-gene-level",
    "href": "pages/quality-control.html#quality-control-at-gene-level",
    "title": "6¬† Quality control",
    "section": "\n6.7 Quality control at gene level",
    "text": "6.7 Quality control at gene level\nThe sections above consider quality control at the spot level. In some datasets, it may also be appropriate to apply quality control procedures or filtering at the gene level. For example, certain genes may be biologically irrelevant for downstream analyses.\nHowever, here we make a distinction between quality control and feature selection. Removing biologically uninteresting genes (such as mitochondrial genes) may also be considered as part of feature selection, since there is no underlying experimental procedure that has failed. Therefore, we will discuss gene-level filtering in the Chapter 8 chapter.",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Quality control</span>"
    ]
  },
  {
    "objectID": "pages/quality-control.html#references",
    "href": "pages/quality-control.html#references",
    "title": "6¬† Quality control",
    "section": "References",
    "text": "References\n\n\n\n\nMaynard, Kristen R., Leonardo Collado-Torres, Lukas M. Weber, Cedric Uytingco, Brianna K. Barry, Stephen R. Williams, Joseph L. Catallini II, et al. 2021. ‚ÄúTranscriptome-Scale Spatial Gene Expression in the Human Dorsolateral Prefrontal Cortex.‚Äù Nature Neuroscience 24: 425‚Äì36. https://doi.org/10.1038/s41593-020-00787-0.\n\n\nMcCarthy, Davis J., Kieran R. Campbell, Aaron T. L. Lun, and Quin F. Wills. 2017. ‚ÄúScater: Pre-Processing, Quality Control, Normalization and Visualization of Single-Cell RNA-seq Data in R.‚Äù Bioinformatics 33 (8): 1179‚Äì86. https://doi.org/10.1093/bioinformatics/btw777.",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Quality control</span>"
    ]
  },
  {
    "objectID": "pages/normalization.html",
    "href": "pages/normalization.html",
    "title": "7¬† Normalization",
    "section": "",
    "text": "7.1 Overview\nHere we apply normalization methods developed for scRNA-seq data, treating each spot as equivalent to one cell.",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Normalization</span>"
    ]
  },
  {
    "objectID": "pages/normalization.html#load-data-from-previous-steps",
    "href": "pages/normalization.html#load-data-from-previous-steps",
    "title": "7¬† Normalization",
    "section": "\n7.2 Load data from previous steps",
    "text": "7.2 Load data from previous steps\nWe start by loading the data object(s) saved after running the analysis steps from the previous chapters. Code to re-run the previous steps is shown in condensed form in Chapter 4.\n\nlibrary(SpatialExperiment)\nspe &lt;- readRDS(\"spe_qc.rds\")",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Normalization</span>"
    ]
  },
  {
    "objectID": "pages/normalization.html#logcounts",
    "href": "pages/normalization.html#logcounts",
    "title": "7¬† Normalization",
    "section": "\n7.3 Logcounts",
    "text": "7.3 Logcounts\nCalculate log-transformed normalized counts (abbreviated as ‚Äúlogcounts‚Äù) using library size factors.\nWe apply the methods implemented in the scater (McCarthy et al. 2017) and scran (Lun, McCarthy, and Marioni 2016) packages, which were originally developed for scRNA-seq data, making the assumption here that these methods can be applied to SRT data by treating spots as equivalent to cells.\nWe use the library size factors methodology since this is the simplest approach, and can easily be applied to SRT data. Alternative approaches that are populare for scRNA-seq data, including normalization by deconvolution, are more difficulty to justify in the context of spot-based SRT data since (i) spots may contain multiple cells from more than one cell type, and (ii) datasets can contain multiple samples (e.g.¬†multiple Visium slides, resulting in sample-specific clustering).\n\nlibrary(scran)\n\n# calculate library size factors\nspe &lt;- computeLibraryFactors(spe)\n\nsummary(sizeFactors(spe))\n##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##   0.1321  0.6312  0.9000  1.0000  1.2849  3.7582\nhist(sizeFactors(spe), breaks = 20)\n\n\n\n\n\n\n\n# calculate logcounts and store in object\nspe &lt;- logNormCounts(spe)\n\n# check\nassayNames(spe)\n##  [1] \"counts\"    \"logcounts\"\ndim(counts(spe))\n##  [1] 33538  3524\ndim(logcounts(spe))\n##  [1] 33538  3524",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Normalization</span>"
    ]
  },
  {
    "objectID": "pages/normalization.html#references",
    "href": "pages/normalization.html#references",
    "title": "7¬† Normalization",
    "section": "References",
    "text": "References\n\n\n\n\nLun, Aaron T. L., Davis J. McCarthy, and John C. Marioni. 2016. ‚ÄúA Step-by-Step Workflow for Low-Level Analysis of Single-Cell RNA-seq Data with Bioconductor.‚Äù F1000Research 5 (2122). https://doi.org/10.12688/f1000research.9501.2.\n\n\nMcCarthy, Davis J., Kieran R. Campbell, Aaron T. L. Lun, and Quin F. Wills. 2017. ‚ÄúScater: Pre-Processing, Quality Control, Normalization and Visualization of Single-Cell RNA-seq Data in R.‚Äù Bioinformatics 33 (8): 1179‚Äì86. https://doi.org/10.1093/bioinformatics/btw777.",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Normalization</span>"
    ]
  },
  {
    "objectID": "pages/feature-selection.html",
    "href": "pages/feature-selection.html",
    "title": "8¬† Feature selection",
    "section": "",
    "text": "8.1 Overview\nHere we apply feature selection methods to identify highly variable genes (HVGs) or spatially variable genes (SVGs), which can then be investigated individually or used as the input for further downstream analyses such as clustering.",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Feature selection</span>"
    ]
  },
  {
    "objectID": "pages/feature-selection.html#load-data-from-previous-steps",
    "href": "pages/feature-selection.html#load-data-from-previous-steps",
    "title": "8¬† Feature selection",
    "section": "\n8.2 Load data from previous steps",
    "text": "8.2 Load data from previous steps\nWe start by loading the data object(s) saved after running the analysis steps from the previous chapters. Code to re-run the previous steps is shown in condensed form in Chapter 4.\n\nlibrary(SpatialExperiment)\nspe &lt;- readRDS(\"spe_logcounts.rds\")",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Feature selection</span>"
    ]
  },
  {
    "objectID": "pages/feature-selection.html#highly-variable-genes-hvgs",
    "href": "pages/feature-selection.html#highly-variable-genes-hvgs",
    "title": "8¬† Feature selection",
    "section": "\n8.3 Highly variable genes (HVGs)",
    "text": "8.3 Highly variable genes (HVGs)\nWe use methods from scran (Lun, McCarthy, and Marioni 2016) to identify a set of top highly variable genes (HVGs), which can be used to define major cell types. These methods were originally developed for single-cell RNA sequencing (scRNA-seq) data, so here we are making the assumption that spots can be treated as equivalent to cells.\nNote that HVGs are defined based only on molecular features (i.e.¬†gene expression), and do not take any spatial information into account. If the biologically meaningful spatial information in this dataset mainly reflects spatial distributions of cell types, then relying on HVGs for downstream analyses may be sufficient. However, many datasets contain further spatial structure that is not captured in this way, which may be investigated using spatially-aware methods such as identifying spatially variable genes (SVGs).\nTo identify HVGs, we first remove mitochondrial genes, since these are very highly expressed in this dataset and are not of main biological interest.\n\n# identify mitochondrial genes\nis_mito &lt;- grepl(\"(^MT-)|(^mt-)\", rowData(spe)$gene_name)\ntable(is_mito)\n##  is_mito\n##  FALSE  TRUE \n##  33525    13\n\n# remove mitochondrial genes\nspe &lt;- spe[!is_mito, ]\ndim(spe)\n##  [1] 33525  3524\n\nThen, we apply methods from scran. This gives us a list of HVGs, which can be used for further downstream analyses. The parameter prop defines how many HVGs we want. For example prop = 0.1 returns the top 10% of genes.\n\nlibrary(scran)\n\n# fit mean-variance relationship\ndec &lt;- modelGeneVar(spe)\n\n# visualize mean-variance relationship\nfit &lt;- metadata(dec)\nplot(fit$mean, fit$var, \n     xlab = \"mean of log-expression\", ylab = \"variance of log-expression\")\ncurve(fit$trend(x), col = \"dodgerblue\", add = TRUE, lwd = 2)\n\n\n\n\n\n\n\n# select top HVGs\ntop_hvgs &lt;- getTopHVGs(dec, prop = 0.1)\nlength(top_hvgs)\n##  [1] 1438",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Feature selection</span>"
    ]
  },
  {
    "objectID": "pages/feature-selection.html#spatially-variable-genes-svgs",
    "href": "pages/feature-selection.html#spatially-variable-genes-svgs",
    "title": "8¬† Feature selection",
    "section": "\n8.4 Spatially variable genes (SVGs)",
    "text": "8.4 Spatially variable genes (SVGs)\nAlternatively, we can apply methods to identify spatially variable genes (SVGs) instead of HVGs. Here, we define SVGs as any genes with spatially correlated patterns of expression across the tissue area.\nSeveral methods to identify SVGs in ST data have recently been developed, which each have various methodological and computational tradeoffs. These include:\n\nnnSVG: available as an R package from Bioconductor and described by Weber et al. (2023)\nSPARK-X: available as an R package from GitHub and described by Zhu, Sun, and Zhou (2021)\nSPARK: available as an R package from GitHub and described by Sun, Zhu, and Zhou (2020)\nSpatialDE: available as a Python package from GitHub and described by Svensson, Teichmann, and Stegle (2018)\n\nAlternatively, standard statistical metrics such as Moran‚Äôs I statistic or Geary‚Äôs C statistic may also be used to rank genes by their observed spatial autocorrelation. However, the methods above tend to be more sensitive, since they have been developed for the specific properties of ST data.\n\n8.4.1 nnSVG\nHere, we demonstrate a short example showing how to identify a set of top SVGs using nnSVG (Weber et al. 2023). This method is available in Bioconductor and can be easily integrated into Bioconductor-based workflows.\nIn this example, we run nnSVG using a small subset of the dataset for faster runtime. We select a subset by subsampling on the set of spots and including stringent filtering for low-expressed genes. A full analysis using all spots for this dataset and default filtering parameters for Visium data from human brain tissue takes around 45 minutes for one Visium sample on a standard laptop.\n\nlibrary(nnSVG)\n\n\n# subsample spots for faster runtime in this example\n# note: skip this step in full analysis\nn &lt;- 100\nset.seed(123)\nix &lt;- sample(seq_len(n), n)\nspe_nnSVG &lt;- spe[, ix]\n\n# filter low-expressed and mitochondrial genes\n# using stringent filtering for faster runtime in this example\n# note: use default filtering in full analysis\nspe_nnSVG &lt;- filter_genes(\n  spe_nnSVG, filter_genes_ncounts = 10, filter_genes_pcspots = 3\n)\n##  Gene filtering: removing mitochondrial genes\n##  removed 0 mitochondrial genes\n##  Gene filtering: retaining genes with at least 10 counts in at least 3% (n = 3) of spatial locations\n##  removed 33353 out of 33525 genes due to low expression\n\n# re-calculate logcounts after filtering\nspe_nnSVG &lt;- logNormCounts(spe_nnSVG)\n\n\n# run nnSVG\nset.seed(123)\nspe_nnSVG &lt;- nnSVG(spe_nnSVG)\n\n\n# investigate results\n\n# show results\nhead(rowData(spe_nnSVG), 3)\n##  DataFrame with 3 rows and 18 columns\n##                          gene_id   gene_name    feature_type subsets_mito\n##                      &lt;character&gt; &lt;character&gt;     &lt;character&gt;    &lt;logical&gt;\n##  ENSG00000074800 ENSG00000074800        ENO1 Gene Expression        FALSE\n##  ENSG00000171603 ENSG00000171603      CLSTN1 Gene Expression        FALSE\n##  ENSG00000162545 ENSG00000162545     CAMK2N1 Gene Expression        FALSE\n##                    sigma.sq    tau.sq       phi    loglik   runtime      mean\n##                   &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt;\n##  ENSG00000074800 0.00840777  0.518011  15.82454  -109.808     0.022   1.75820\n##  ENSG00000171603 0.43102027  0.298698  18.12310  -123.212     0.020   2.07433\n##  ENSG00000162545 0.15373440  0.547736   2.38046  -119.576     0.013   2.63576\n##                        var     spcov   prop_sv loglik_lm   LR_stat      rank\n##                  &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt;\n##  ENSG00000074800  0.530929 0.0521523 0.0159716  -109.735 -0.145454       167\n##  ENSG00000171603  0.741077 0.3164987 0.5906665  -126.409  6.394009        86\n##  ENSG00000162545  0.702846 0.1487576 0.2191603  -123.760  8.368951        70\n##                       pval      padj\n##                  &lt;numeric&gt; &lt;numeric&gt;\n##  ENSG00000074800 1.0000000 1.0000000\n##  ENSG00000171603 0.0408845 0.0817690\n##  ENSG00000162545 0.0152302 0.0374227\n\n# number of significant SVGs\ntable(rowData(spe_nnSVG)$padj &lt;= 0.05)\n##  \n##  FALSE  TRUE \n##     96    76\n\n# show results for top n SVGs\nrowData(spe_nnSVG)[order(rowData(spe_nnSVG)$rank)[1:6], ]\n##  DataFrame with 6 rows and 18 columns\n##                          gene_id   gene_name    feature_type subsets_mito\n##                      &lt;character&gt; &lt;character&gt;     &lt;character&gt;    &lt;logical&gt;\n##  ENSG00000197971 ENSG00000197971         MBP Gene Expression        FALSE\n##  ENSG00000123560 ENSG00000123560        PLP1 Gene Expression        FALSE\n##  ENSG00000109846 ENSG00000109846       CRYAB Gene Expression        FALSE\n##  ENSG00000173786 ENSG00000173786         CNP Gene Expression        FALSE\n##  ENSG00000131095 ENSG00000131095        GFAP Gene Expression        FALSE\n##  ENSG00000160307 ENSG00000160307       S100B Gene Expression        FALSE\n##                   sigma.sq    tau.sq       phi    loglik   runtime      mean\n##                  &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt;\n##  ENSG00000197971   3.92430  0.175336   0.93014  -118.372     0.020   3.78073\n##  ENSG00000123560   3.23544  0.461590   1.03983  -140.269     0.017   2.86143\n##  ENSG00000109846   1.89968  0.281795   1.88555  -126.692     0.016   1.86058\n##  ENSG00000173786   2.28793  0.402524   1.02675  -129.206     0.015   1.79558\n##  ENSG00000131095   2.23709  0.461297   2.49083  -149.004     0.016   1.94543\n##  ENSG00000160307   1.24179  0.155737   5.76279  -129.722     0.014   1.82695\n##                        var     spcov   prop_sv loglik_lm   LR_stat      rank\n##                  &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt;\n##  ENSG00000197971   2.76535  0.523969  0.957231  -192.250  147.7556         1\n##  ENSG00000123560   3.02555  0.628613  0.875146  -196.746  112.9549         2\n##  ENSG00000109846   1.88123  0.740785  0.870824  -172.988   92.5906         3\n##  ENSG00000173786   1.97274  0.842396  0.850388  -175.363   92.3137         4\n##  ENSG00000131095   2.71281  0.768823  0.829047  -191.291   84.5739         5\n##  ENSG00000160307   1.46946  0.609953  0.888562  -160.636   61.8281         6\n##                         pval        padj\n##                    &lt;numeric&gt;   &lt;numeric&gt;\n##  ENSG00000197971 0.00000e+00 0.00000e+00\n##  ENSG00000123560 0.00000e+00 0.00000e+00\n##  ENSG00000109846 0.00000e+00 0.00000e+00\n##  ENSG00000173786 0.00000e+00 0.00000e+00\n##  ENSG00000131095 0.00000e+00 0.00000e+00\n##  ENSG00000160307 3.75255e-14 1.07573e-12\n\n# identify top-ranked SVG\nrowData(spe_nnSVG)$gene_name[which(rowData(spe_nnSVG)$rank == 1)]\n##  [1] \"MBP\"\n\n\n8.4.2 Downstream analyses\nThe set of top SVGs from nnSVG may then be investigated further, e.g.¬†by plotting the spatial expression of several top genes and by comparing the list of top genes with known gene sets associated with biological processes of interest in the dataset. The set of top SVGs may also be used as the input for further downstream analyses such as spatially-aware clustering to define spatial domains (see Chapter 10).",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Feature selection</span>"
    ]
  },
  {
    "objectID": "pages/feature-selection.html#references",
    "href": "pages/feature-selection.html#references",
    "title": "8¬† Feature selection",
    "section": "References",
    "text": "References\n\n\n\n\nLun, Aaron T. L., Davis J. McCarthy, and John C. Marioni. 2016. ‚ÄúA Step-by-Step Workflow for Low-Level Analysis of Single-Cell RNA-seq Data with Bioconductor.‚Äù F1000Research 5 (2122). https://doi.org/10.12688/f1000research.9501.2.\n\n\nSun, Shiquan, Jiaqiang Zhu, and Xiang Zhou. 2020. ‚ÄúStatistical Analysis of Spatial Expression Patterns for Spatially Resolved Transcriptomic Studies.‚Äù Nature Methods 17: 193‚Äì200. https://doi.org/10.1038/s41592-019-0701-7.\n\n\nSvensson, Valentine, Sarah A. Teichmann, and Oliver Stegle. 2018. ‚ÄúSpatialDE: Identification of Spatially Variable Genes.‚Äù Nature Methods 15: 343‚Äì46. https://doi.org/10.1038/nmeth.4636.\n\n\nWeber, Lukas M., Arkajyoti Saha, Abhirup Datta, Kasper D. Hansen, and Stephanie C. Hicks. 2023. ‚ÄúnnSVG for the Scalable Identification of Spatially Variable Genes Using Nearest-Neighbor Gaussian Processes.‚Äù Nature Communications 14: 4059. https://doi.org/10.1038/s41467-023-39748-z.\n\n\nZhu, Jiaqiang, Shiquan Sun, and Xiang Zhou. 2021. ‚ÄúSPARK-X: Non-Parametric Modeling Enables Scalable and Robust Detection of Spatial Expression Patterns for Large Spatial Transcriptomic Studies.‚Äù Genome Biology 22: 184. https://doi.org/10.1186/s13059-021-02404-0.",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Feature selection</span>"
    ]
  },
  {
    "objectID": "pages/dimensionality-reduction.html",
    "href": "pages/dimensionality-reduction.html",
    "title": "9¬† Dimensionality reduction",
    "section": "",
    "text": "9.1 Overview\nIn this chapter, we apply dimensionality reduction methods to visualize the data and to generate inputs for further downstream analyses.",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Dimensionality reduction</span>"
    ]
  },
  {
    "objectID": "pages/dimensionality-reduction.html#load-data-from-previous-steps",
    "href": "pages/dimensionality-reduction.html#load-data-from-previous-steps",
    "title": "9¬† Dimensionality reduction",
    "section": "\n9.2 Load data from previous steps",
    "text": "9.2 Load data from previous steps\nWe start by loading the data object(s) saved after running the analysis steps from the previous chapters. Code to re-run the previous steps is shown in condensed form in Chapter 4.\n\nlibrary(SpatialExperiment)\nspe &lt;- readRDS(\"spe_hvgs.rds\")\ntop_hvgs &lt;- readRDS(\"top_hvgs.rds\")",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Dimensionality reduction</span>"
    ]
  },
  {
    "objectID": "pages/dimensionality-reduction.html#principal-component-analysis-pca",
    "href": "pages/dimensionality-reduction.html#principal-component-analysis-pca",
    "title": "9¬† Dimensionality reduction",
    "section": "\n9.3 Principal component analysis (PCA)",
    "text": "9.3 Principal component analysis (PCA)\nApply principal component analysis (PCA) to the set of top highly variable genes (HVGs) to reduce the dimensionality of the dataset, and retain the top 50 principal components (PCs) for further downstream analyses.\nThis is done for two reasons: (i) to reduce noise due to random variation in expression of biologically uninteresting genes, which are assumed to have expression patterns that are independent of each other, and (ii) to improve computational efficiency during downstream analyses.\nWe use the computationally efficient implementation of PCA provided in the scater package (McCarthy et al. 2017). This implementation uses randomization, and therefore requires setting a random seed for reproducibility.\n\nlibrary(scater)\n\n\n# compute PCA\nset.seed(123)\nspe &lt;- runPCA(spe, subset_row = top_hvgs)\n\nreducedDimNames(spe)\n##  [1] \"PCA\"\ndim(reducedDim(spe, \"PCA\"))\n##  [1] 3524   50",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Dimensionality reduction</span>"
    ]
  },
  {
    "objectID": "pages/dimensionality-reduction.html#uniform-manifold-approximation-and-projection-umap",
    "href": "pages/dimensionality-reduction.html#uniform-manifold-approximation-and-projection-umap",
    "title": "9¬† Dimensionality reduction",
    "section": "\n9.4 Uniform Manifold Approximation and Projection (UMAP)",
    "text": "9.4 Uniform Manifold Approximation and Projection (UMAP)\nWe also run UMAP on the set of top 50 PCs and retain the top 2 UMAP components, which will be used for visualization purposes.\n\n# compute UMAP on top 50 PCs\nset.seed(123)\nspe &lt;- runUMAP(spe, dimred = \"PCA\")\n\nreducedDimNames(spe)\n##  [1] \"PCA\"  \"UMAP\"\ndim(reducedDim(spe, \"UMAP\"))\n##  [1] 3524    2\n\n# update column names for easier plotting\ncolnames(reducedDim(spe, \"UMAP\")) &lt;- paste0(\"UMAP\", 1:2)",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Dimensionality reduction</span>"
    ]
  },
  {
    "objectID": "pages/dimensionality-reduction.html#visualizations",
    "href": "pages/dimensionality-reduction.html#visualizations",
    "title": "9¬† Dimensionality reduction",
    "section": "\n9.5 Visualizations",
    "text": "9.5 Visualizations\nGenerate plots using plotting functions from the ggspavis package. In the next chapter on clustering, we will add cluster labels to these reduced dimension plots.\n\nlibrary(ggspavis)\n\n\n# plot top 2 PCA dimensions\nplotDimRed(spe, plot_type = \"PCA\")\n\n\n\n\n\n\n\n# plot top 2 UMAP dimensions\nplotDimRed(spe, plot_type = \"UMAP\")",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Dimensionality reduction</span>"
    ]
  },
  {
    "objectID": "pages/dimensionality-reduction.html#references",
    "href": "pages/dimensionality-reduction.html#references",
    "title": "9¬† Dimensionality reduction",
    "section": "References",
    "text": "References\n\n\n\n\nMcCarthy, Davis J., Kieran R. Campbell, Aaron T. L. Lun, and Quin F. Wills. 2017. ‚ÄúScater: Pre-Processing, Quality Control, Normalization and Visualization of Single-Cell RNA-seq Data in R.‚Äù Bioinformatics 33 (8): 1179‚Äì86. https://doi.org/10.1093/bioinformatics/btw777.",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Dimensionality reduction</span>"
    ]
  },
  {
    "objectID": "pages/clustering.html",
    "href": "pages/clustering.html",
    "title": "10¬† Clustering",
    "section": "",
    "text": "10.1 Overview\nIn ST data, we can apply clustering algorithms to identify ‚Äòspatial domains‚Äô, which represent spatially defined regions consisting of relatively consistent gene expression profiles. For example, spatial domains may consist of regions containing cells from a single cell type or a consistent mixture of cell types.\nSeveral alternative approaches exist for these analyses. For example, we can apply standard clustering algorithms from single-cell workflows to identify cell types without taking any spatial information into account, and then analyze the spatial distributions of these cell types. Alternatively, we can use spatially-aware clustering algorithms that directly take the spatial coordinates of the measurements into account. For larger datasets, there may also be important computational tradeoffs between the various approaches.\nIt is also important to keep in mind that when we use clustering to define cell types and/or states, these can be defined at various resolutions (or even on a continuum). The optimal number of clusters depends on the biological context ‚Äì in particular, there is no ‚Äútrue‚Äù number of clusters, since this depends on the biological context (e.g.¬†if we are comparing major cell populations vs.¬†comparing rare subtypes), so the choice of the optimal number of clusters requires some judgment and biological interpretation.\nOnce we have identified spatial domains, these can then be further investigated in additional downstream analyses.",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Clustering</span>"
    ]
  },
  {
    "objectID": "pages/clustering.html#load-data-from-previous-steps",
    "href": "pages/clustering.html#load-data-from-previous-steps",
    "title": "10¬† Clustering",
    "section": "\n10.2 Load data from previous steps",
    "text": "10.2 Load data from previous steps\nWe start by loading the data object(s) saved after running the analysis steps from the previous chapters. Code to re-run the previous steps is shown in condensed form in Chapter 4.\n\nlibrary(SpatialExperiment)\nspe &lt;- readRDS(\"spe_reduceddims.rds\")\nspe_full &lt;- readRDS(\"spe_logcounts.rds\")",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Clustering</span>"
    ]
  },
  {
    "objectID": "pages/clustering.html#non-spatial-clustering",
    "href": "pages/clustering.html#non-spatial-clustering",
    "title": "10¬† Clustering",
    "section": "\n10.3 Non-spatial clustering",
    "text": "10.3 Non-spatial clustering\n\n10.3.1 Clustering using HVGs\nHere, we perform clustering by applying standard clustering methods developed for single-cell RNA sequencing data, using molecular features (gene expression) only. We apply graph-based clustering using the Walktrap method implemented in scran (Lun, McCarthy, and Marioni 2016), applied to the top 50 PCs calculated on the set of top HVGs.\nIn the context of spatial data, this is the same as applying clustering to identify cell types in single-cell data (although each spot may contain one or more cells, depending on the platform and tissue cell density), and means that we are assuming that biologically informative spatial distribution patterns of cell types can be detected from the molecular features (gene expression).\n\nlibrary(scran)\n\n\n# graph-based clustering\nset.seed(123)\nk &lt;- 10\ng &lt;- buildSNNGraph(spe, k = k, use.dimred = \"PCA\")\ng_walk &lt;- igraph::cluster_walktrap(g)\nclus &lt;- g_walk$membership\ntable(clus)\n##  clus\n##     1    2    3    4    5    6 \n##   359 1187  447  291  693  547\n\n# store cluster labels in column 'label' in colData\ncolLabels(spe) &lt;- factor(clus)\n\nVisualize the clusters by plotting in (i) spatial (x-y) coordinates on the tissue slide, and (ii) reduced dimension space (PCA or UMAP). We use plotting functions from the ggspavis package.\nFor reference, we also display the ground truth (manually annotated) labels available for this dataset (in spatial coordinates).\nFrom the visualizations, we can see that the clustering reproduces the known biological structure (cortical layers), although not perfectly. The clusters are also separated in UMAP space, but again not perfectly.\n\nlibrary(ggspavis)\n\n\n# plot clusters in spatial x-y coordinates\nplotSpots(spe, annotate = \"label\", \n          pal = \"libd_layer_colors\")\n\n\n\n\n\n\n\n# plot ground truth labels in spatial coordinates\nplotSpots(spe, annotate = \"ground_truth\", \n          pal = \"libd_layer_colors\")\n\n\n\n\n\n\n\n\n# plot clusters in PCA reduced dimensions\nplotDimRed(spe, plot_type = \"PCA\", \n           annotate = \"label\", pal = \"libd_layer_colors\")\n\n\n\n\n\n\n\n# plot clusters in UMAP reduced dimensions\nplotDimRed(spe, plot_type = \"UMAP\", \n           annotate = \"label\", pal = \"libd_layer_colors\")",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Clustering</span>"
    ]
  },
  {
    "objectID": "pages/clustering.html#spatially-aware-clustering",
    "href": "pages/clustering.html#spatially-aware-clustering",
    "title": "10¬† Clustering",
    "section": "\n10.4 Spatially-aware clustering",
    "text": "10.4 Spatially-aware clustering\nThe example above shows that non-spatial clustering can capture some spatial relationships in ST data, primarily if these are due to spatially distributed cell types and where the cell types can be identified from their gene expression profiles alone. However, this does not directly make use of the spatial information contained in the measurements.\nIn many ST datasets, we can uncover further structure by performing analyses that directly take spatial information into account. Below, we demonstrate examples of these types of analyses, which we refer to as ‚Äòspatially-aware clustering‚Äô.\n\n10.4.1 Clustering using SVGs\nOne way to perform spatially-aware clustering is to first perform spatially-aware feature selection to identify a set of top spatially variable genes (SVGs) (see Chapter 8) and then use the set of top SVGs as the input for clustering.\nIn this case, the spatial information is taken into account during the feature selection stage, where we select a set of top SVGs instead of top HVGs. For the clustering stage, we can use the same algorithms as for non-spatial clustering.\nHere, we demonstrate an example using nnSVG (Weber et al. 2023) to select the set of top SVGs. Note that in this example, we run nnSVG using a small subset of the dataset for faster runtime. For a full analysis, the full dataset should be used (see Chapter 8 for more details).\n\nlibrary(nnSVG)\n\n\n# subsample spots for faster runtime in this example\n# note: skip this step in full analysis\nn &lt;- 100\nset.seed(123)\nix &lt;- sample(seq_len(n), n)\nspe_nnSVG &lt;- spe_full[, ix]  ## note: using full object from logcounts step\n\n# filter low-expressed and mitochondrial genes\n# using stringent filtering for faster runtime in this example\n# note: use default filtering in full analysis\nspe_nnSVG &lt;- filter_genes(\n  spe_nnSVG, filter_genes_ncounts = 10, filter_genes_pcspots = 3\n)\n##  Gene filtering: removing mitochondrial genes\n##  removed 13 mitochondrial genes\n##  Gene filtering: retaining genes with at least 10 counts in at least 3% (n = 3) of spatial locations\n##  removed 33353 out of 33525 genes due to low expression\n\n# re-calculate logcounts after filtering\nspe_nnSVG &lt;- logNormCounts(spe_nnSVG)\n\n\n# run nnSVG\nset.seed(123)\nspe_nnSVG &lt;- nnSVG(spe_nnSVG)\n\nNow that we have run nnSVG, we can select at set of top SVGs (instead of HVGs), and use these as the input for the subsequent clustering steps.\n\n# select top SVGs\n# note: using small subset in this example\n# use larger set (e.g. top 1000 genes) in full analysis\nn_top &lt;- 50\nix_top &lt;- order(rowData(spe_nnSVG)$rank)[1:n]\ntop_svgs &lt;- rowData(spe_nnSVG)[ix_top, \"gene_id\"]\n\n\nlibrary(scater)\nlibrary(scran)\n\n\n# dimensionality reduction\n# compute PCA\n# note: using small number of components in this example\n# use larger number (e.g. ncomponents = 50) in full analysis\nset.seed(123)\nspe_nnSVG &lt;- runPCA(spe_nnSVG, ncomponents = 10, subset_row = top_svgs)\n\n\n# graph-based clustering\nset.seed(123)\nk &lt;- 10\ng &lt;- buildSNNGraph(spe_nnSVG, k = k, use.dimred = \"PCA\")\ng_walk &lt;- igraph::cluster_walktrap(g)\nclus &lt;- g_walk$membership\ntable(clus)\n##  clus\n##   1  2  3  4  5 \n##   6  6 53 24 11\n\n# store cluster labels in column 'label' in colData\ncolLabels(spe_nnSVG) &lt;- factor(clus)\n\n\n10.4.2 Clustering using concatenated features\nAn alternative strategy is to perform clustering on a set of concatenated columns of non-spatial and spatial features. For example, we can concatenate columns of non-spatial molecular features (e.g.¬†top PCs calculated on the set of top HVGs) and columns of spatial features (e.g.¬†x and y coordinates). In this case, a tuning parameter to scale the relative value ranges of the columns controls the relative weight between the two data modalities. If the tuning parameter is chosen poorly, either the molecular or spatial features may dominate the clustering. An example of this strategy was used in Maynard et al. (2021).\n\n10.4.3 Spatially-aware clustering algorithms\nAlternatively, we can use a spatially-aware clustering algorithm, which directly uses the spatial coordinates of the measurements within the clustering algorithm. Various algorithms have been developed, which have different advantages and make different assumptions, for example identifying spatially compact or spatially connected clusters.\nExamples of spatially-aware clustering algorithms include:\n\nBayesSpace: available as an R package from Bioconductor and described by Zhao et al. (2021)\nBANKSY: available as an R package from Bioconductor version 3.9 onwards and described by Singhal et al. (2024)\nSpaGCN: available as a Python package from GitHub and described by Hu et al. (2021)\nPRECAST: available as an R package from CRAN and described by Liu et al. (2023)",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Clustering</span>"
    ]
  },
  {
    "objectID": "pages/clustering.html#references",
    "href": "pages/clustering.html#references",
    "title": "10¬† Clustering",
    "section": "References",
    "text": "References\n\n\n\n\nHu, Jian, Xiangjie Li, Kyle Coleman, Amelia Schroeder, Nan Ma, David J. Irwin, Edward B. Lee, Russell T. Shinohara, and Mingyao Li. 2021. ‚ÄúSpaGCN: Integrating Gene Expression, Spatial Location and Histology to Identify Spatial Domains and Spatially Variable Genes by Graph Convolutional Network.‚Äù Nature Methods 18: 1342‚Äì51. https://doi.org/10.1038/s41592-021-01255-8.\n\n\nLiu, Wei, Xu Liao, Ziye Luo, Yi Yang, Mai Chan Lau, Yuling Jiao, Xingjie Shi, et al. 2023. ‚ÄúProbabilistic Embedding, Clustering, and Alignment for Integrating Spatial Transcriptomics Data with PRECAST.‚Äù Nature Communications 14: 296. https://doi.org/10.1038/s41467-023-35947-w.\n\n\nLun, Aaron T. L., Davis J. McCarthy, and John C. Marioni. 2016. ‚ÄúA Step-by-Step Workflow for Low-Level Analysis of Single-Cell RNA-seq Data with Bioconductor.‚Äù F1000Research 5 (2122). https://doi.org/10.12688/f1000research.9501.2.\n\n\nMaynard, Kristen R., Leonardo Collado-Torres, Lukas M. Weber, Cedric Uytingco, Brianna K. Barry, Stephen R. Williams, Joseph L. Catallini II, et al. 2021. ‚ÄúTranscriptome-Scale Spatial Gene Expression in the Human Dorsolateral Prefrontal Cortex.‚Äù Nature Neuroscience 24: 425‚Äì36. https://doi.org/10.1038/s41593-020-00787-0.\n\n\nSinghal, Vipul, Nigel Chou, Joseph Lee, Yifei Yue, Jinyue Liu, Wan Kee Chock, Li Lin, et al. 2024. ‚ÄúBANKSY Unifies Cell Typing and Tissue Domain Segmentation for Scalable Spatial Omics Data Analysis.‚Äù Nature Genetics. https://doi.org/10.1038/s41588-024-01664-3.\n\n\nWeber, Lukas M., Arkajyoti Saha, Abhirup Datta, Kasper D. Hansen, and Stephanie C. Hicks. 2023. ‚ÄúnnSVG for the Scalable Identification of Spatially Variable Genes Using Nearest-Neighbor Gaussian Processes.‚Äù Nature Communications 14: 4059. https://doi.org/10.1038/s41467-023-39748-z.\n\n\nZhao, Edward, Matthew R. Stone, Xing Ren, Jamie Guenthoer, Kimberly S. Smythe, Thomas Pulliam, Stephen R. Williams, et al. 2021. ‚ÄúSpatial Transcriptomics at Subspot Resolution with BayesSpace.‚Äù Nature Biotechnology 39: 1375‚Äì84. https://doi.org/10.1038/s41587-021-00935-2.",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Clustering</span>"
    ]
  },
  {
    "objectID": "pages/spot-deconvolution.html",
    "href": "pages/spot-deconvolution.html",
    "title": "11¬† Spot deconvolution",
    "section": "",
    "text": "11.1 Overview\nSpot-level ST data (e.g.¬†from the 10x Genomics Visium platform) can contain zero, one, or multiple cells per spot, depending on the spatial resolution of the platform and the tissue cell density. This characteristic of the data affects several steps in analysis workflows, including quality control (Chapter 6) and clustering (Chapter 10).\nNote that this is also a characteristic of ST data that is distinct from single-cell RNA sequencing data, so here we cannot easily apply existing methods from single-cell workflows.\nIn this section, we will demonstrate methods to deconvolve cell types per spot.",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Spot deconvolution</span>"
    ]
  },
  {
    "objectID": "pages/spot-deconvolution.html#previous-steps",
    "href": "pages/spot-deconvolution.html#previous-steps",
    "title": "11¬† Spot deconvolution",
    "section": "\n11.2 Previous steps",
    "text": "11.2 Previous steps",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Spot deconvolution</span>"
    ]
  },
  {
    "objectID": "pages/spot-deconvolution.html#load-data-from-previous-steps",
    "href": "pages/spot-deconvolution.html#load-data-from-previous-steps",
    "title": "11¬† Spot deconvolution",
    "section": "\n11.3 Load data from previous steps",
    "text": "11.3 Load data from previous steps\nWe start by loading the data object(s) saved after running the analysis steps from the previous chapters. Code to re-run the previous steps is shown in condensed form in Chapter 4.\n\nlibrary(SpatialExperiment)\nspe &lt;- readRDS(\"spe_cluster.rds\")",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Spot deconvolution</span>"
    ]
  },
  {
    "objectID": "pages/spot-deconvolution.html#number-of-cells-per-spot",
    "href": "pages/spot-deconvolution.html#number-of-cells-per-spot",
    "title": "11¬† Spot deconvolution",
    "section": "\n11.4 Number of cells per spot",
    "text": "11.4 Number of cells per spot\nThe following figure provides an overview of the number of cells per spot in this dataset, which is known in this dataset and stored in a column in colData in the SpatialExperiment object. We use a visualization function from ggspavis to generate the plot.\nWe see that spots in this dataset contain around 0-10 cells, with a mode of 3. Therefore, it is plausible that some spots contain multiple cell types, and spot-level deconvolution could improve downstream analyses by deconvolving these cell types.\n\nlibrary(ggspavis)\n\n# plot number of cells per spot\nplotSpotQC(spe, plot_type = \"histogram\", x_metric = \"cell_count\") + \n  xlab(\"number of cells\") + \n  ggtitle(\"Number of cells per spot\")",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Spot deconvolution</span>"
    ]
  },
  {
    "objectID": "pages/spot-deconvolution.html#references",
    "href": "pages/spot-deconvolution.html#references",
    "title": "11¬† Spot deconvolution",
    "section": "References",
    "text": "References",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Spot deconvolution</span>"
    ]
  },
  {
    "objectID": "pages/spatial-registration.html",
    "href": "pages/spatial-registration.html",
    "title": "12¬† Spatial registration",
    "section": "",
    "text": "12.1 Overview\nSpatial registration methods use gene expression profiles for cell populations of interest from single-cell RNA sequencing data as a reference, and use these single-cell expression profiles to ‚Äòspatially register‚Äô the spatial coordinates of observations corresponding to these cell populations in spatial transcriptomics data.\nFor spot-based ST data, this is the same as spot deconvolution using reference-based methods (Chapter 11).\nFor molecule-based ST data, this may be used as an alternative to clustering to identify cell populations after aggregation to cellular resolution (Chapter 10).",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Spatial registration</span>"
    ]
  },
  {
    "objectID": "pages/differential-expression.html",
    "href": "pages/differential-expression.html",
    "title": "13¬† Differential expression",
    "section": "",
    "text": "13.1 Overview\nIn this chapter, we perform differential expression testing between clusters or spatial domains to identify representative marker genes for each cluster or spatial domain.",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Differential expression</span>"
    ]
  },
  {
    "objectID": "pages/differential-expression.html#load-data-from-previous-steps",
    "href": "pages/differential-expression.html#load-data-from-previous-steps",
    "title": "13¬† Differential expression",
    "section": "\n13.2 Load data from previous steps",
    "text": "13.2 Load data from previous steps\nWe start by loading the data object(s) saved after running the analysis steps from the previous chapters. Code to re-run the previous steps is shown in condensed form in Chapter 4.\n\nlibrary(SpatialExperiment)\nspe &lt;- readRDS(\"spe_cluster.rds\")",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Differential expression</span>"
    ]
  },
  {
    "objectID": "pages/differential-expression.html#differential-expression-testing",
    "href": "pages/differential-expression.html#differential-expression-testing",
    "title": "13¬† Differential expression",
    "section": "\n13.3 Differential expression testing",
    "text": "13.3 Differential expression testing\nIdentify representative marker genes for each cluster or spatial domain by testing for differential gene expression between clusters.\nHere, we use the findMarkers implementation in scran (Lun, McCarthy, and Marioni 2016), using a binomial test, which tests for genes that differ in the proportion expressed vs.¬†not expressed between clusters. This is a more stringent test than the default t-tests, and tends to select genes that are easier to interpret and validate experimentally.\n\nlibrary(scran)\nlibrary(scater)\nlibrary(pheatmap)\n\n\n# set gene names as row names for easier plotting\nrownames(spe) &lt;- rowData(spe)$gene_name\n\n# test for marker genes\nmarkers &lt;- findMarkers(spe, test = \"binom\", direction = \"up\")\n\n# returns a list with one DataFrame per cluster\nmarkers\n##  List of length 6\n##  names(6): 1 2 3 4 5 6\n\n\n# plot log-fold changes for one cluster over all other clusters\n# selecting cluster 1\ninteresting &lt;- markers[[1]]\nbest_set &lt;- interesting[interesting$Top &lt;= 5, ]\nlogFCs &lt;- getMarkerEffects(best_set)\n\npheatmap(logFCs, breaks = seq(-5, 5, length.out = 101))\n\n\n\n\n\n\n\n\n# plot log-transformed normalized expression of top genes for one cluster\ntop_genes &lt;- head(rownames(interesting))\n\nplotExpression(spe, x = \"label\", features = top_genes)",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Differential expression</span>"
    ]
  },
  {
    "objectID": "pages/differential-expression.html#pseudobulking",
    "href": "pages/differential-expression.html#pseudobulking",
    "title": "13¬† Differential expression",
    "section": "\n13.4 Pseudobulking",
    "text": "13.4 Pseudobulking\nAlternatively, we can proceed by manually aggregating the counts per cluster or spatial domain, which is referred to as ‚Äòpseudobulking‚Äô. Then, we can perform differential expression testing between the pseudobulked clusters or spatial domains.",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Differential expression</span>"
    ]
  },
  {
    "objectID": "pages/differential-expression.html#references",
    "href": "pages/differential-expression.html#references",
    "title": "13¬† Differential expression",
    "section": "References",
    "text": "References\n\n\n\n\nLun, Aaron T. L., Davis J. McCarthy, and John C. Marioni. 2016. ‚ÄúA Step-by-Step Workflow for Low-Level Analysis of Single-Cell RNA-seq Data with Bioconductor.‚Äù F1000Research 5 (2122). https://doi.org/10.12688/f1000research.9501.2.",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Differential expression</span>"
    ]
  },
  {
    "objectID": "pages/multiple-samples.html",
    "href": "pages/multiple-samples.html",
    "title": "14¬† Multiple samples",
    "section": "",
    "text": "14.1 Overview\nIn the preceding chapters, we have focused on spatial transcriptomics datasets consisting of a single tissue section, which we refer to as a sample.\nDatasets consisting of multiple samples from one or more biological conditions are used to study a variety of biological questions, such as characterizing biological variability within replicate tissue samples, or differential comparisons between biological conditions.\nThese datasets require additional analysis methods that can make full use of the information contained in multiple samples in a computationally efficient and statistically rigorous manner.",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Multiple samples</span>"
    ]
  },
  {
    "objectID": "pages/spatial-co-localization.html",
    "href": "pages/spatial-co-localization.html",
    "title": "15¬† Spatial co-localization",
    "section": "",
    "text": "15.1 Overview\nIn this chapter, we will show examples of analyses to investigate spatial co-localization of cell types.\nFor these analyses, we will use a different dataset that provides single-cell spatial resolution, e.g.¬†from the 10x Genomics Xenium platform.",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Spatial co-localization</span>"
    ]
  },
  {
    "objectID": "pages/spatial-co-localization.html#load-data-from-previous-steps",
    "href": "pages/spatial-co-localization.html#load-data-from-previous-steps",
    "title": "15¬† Spatial co-localization",
    "section": "\n15.2 Load data from previous steps",
    "text": "15.2 Load data from previous steps\nWe start by loading the data object(s) saved after running the analysis steps from the previous chapters. Code to re-run the previous steps is shown in condensed form in Chapter 4.",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Spatial co-localization</span>"
    ]
  },
  {
    "objectID": "pages/spatial-co-localization.html#spatial-co-localization-of-cell-types-within-a-single-sample",
    "href": "pages/spatial-co-localization.html#spatial-co-localization-of-cell-types-within-a-single-sample",
    "title": "15¬† Spatial co-localization",
    "section": "\n15.3 Spatial co-localization of cell types within a single sample",
    "text": "15.3 Spatial co-localization of cell types within a single sample\nWe will use the spicyR Bioconductor package (Canete et al. 2022) for the following examples.",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Spatial co-localization</span>"
    ]
  },
  {
    "objectID": "pages/spatial-co-localization.html#references",
    "href": "pages/spatial-co-localization.html#references",
    "title": "15¬† Spatial co-localization",
    "section": "References",
    "text": "References\n\n\n\n\nCanete, Nicolas P., Sourish S. Iyengar, John T. Ormerod, Heeva Baharlou, Andrew N. Harman, and Ellis Patrick. 2022. ‚ÄúspicyR: Spatial Analysis of in Situ Cytometry Data in R.‚Äù Bioinformatics 38: 3099‚Äì3105. https://doi.org/10.1093/bioinformatics/btac268.",
    "crumbs": [
      "Analysis steps",
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Spatial co-localization</span>"
    ]
  },
  {
    "objectID": "pages/workflows.html",
    "href": "pages/workflows.html",
    "title": "16¬† Workflows",
    "section": "",
    "text": "This part contains several extended chapters containing examples of complete analysis workflows.\nEach chapter uses a specific example dataset and a selected set of analysis methods. The workflows have been selected to showcase certain types of analyses or datasets from specific technological platforms. Each workflow includes some discussion on the analyses and methods used, and interactive R code examples.\nFor more details on the individual analysis steps, see the chapters in the previous part (Chapter 4).\n\n\n\n Back to top",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Workflows</span>"
    ]
  }
]